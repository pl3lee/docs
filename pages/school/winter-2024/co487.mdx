# CO487 - Applied Cryptography
This page is a condensed version of the course notes for CO487. It is intended to be a quick reference for the course material in order to help me study for the final exam.
## Definitions
Here are some terms and concepts that we are expected to memorize
- **Confidentiality**: Keeping data secret from all but those authorized to see it.
- **Data integrity**: Ensuring data has not been altered by unauthorized means, meaning the data has not been modified or tampered with.
- **Data origin authentication**: Corroborating the source of data, meaning that the data is from the source it claims to be from.
- **Non-repudiation**: Preventing an entity from denying previous commitments or actions.
- **Totally Insecure**: Given a symmetric key encryption scheme, if an adversary can recover the secret key $k$, or systematically recover plaintext from ciphertext, without necessarily learning $k$, then the scheme is said to be totally insecure (or totally broken).
- **Semantically Secure**: If the adversary cannot learn any partial information about the plaintext from the ciphertext (except possibly its length), the encryption scheme is said to be semantically secure.
- **Secure symmetric-key encryption scheme**: A symmetric-key encryption scheme is secure if it is semantically secure against chosen-plaintext attack by a computationally bounded adversary.
- **Security level of a cryptographic scheme**: A cryptographic scheme is said to have a security level of $\ell$ bits if the fastest known attack on the scheme takes approximately $2^\ell$ operations.
- **Preimage-resistant hash function**: A hash function $H: \{0,1\}^* \to \{0,1\}^n$ is preimage resistant if, given a hash value $y \in_R \{0,1\}^n$, it is computationally infeasible to find any $x \in \{0,1\}^*$ with $H(x) = y$ ($x$ is called a preimage of $y$). That is, given $y$, it is almost impossible to find the preimage.
- **Second-preimage resistant hash function**: A hash function $H: \{0,1\}^* \to \{0,1\}^n$ is 2nd preimage resistant if given $x \in_R \{0,1\}^*$, it is computationally infeasible to find another $x' \in \{0,1\}^*$, where $x \neq x'$, such that $H(x) = H(x')$. That is, it is impossible to find another string that has the same hash value.
- **Collision-resistant hash function**: A hash function $H: \{0,1\}^* \to \{0,1\}^n$ is collision resistant if it is computationally infeasible to find $x, x' \in \{0,1\}^*$ with $x \neq x'$ such that $H(x) = H(x')$. Such a pair $(x,x')$ is called a collision.
- **Secure MAC scheme**: A MAC scheme is secure if given some tags $\text{MAC}_k(x_i)$ for messages $x_i'$s of one's own choosing, it is computationally infeasible to compute a message-tag pair $(x, \text{MAC}_k(x))$ for a new message $x$. More concisely, a MAC scheme is secure if it is existentially unforgeable against chosen-message attack.
- **Secure authenticated encryption scheme**: An authenticated encryption scheme $AE$ is AE-secure if $AE$ is semantically secure against chosen-plaintext attack, and $AE$ has ciphertext integrity, i.e. an adversary who is able to obtain ciphertext/tag pairs for messages of its own choosing cannot produce a valid ciphertext/tag pair for a new message.
- **Input size**: The input size is the number of bits required to write down the input using a reasonable encoding.
- **Running time of an algorithm**: The running time of an algorithm is an upper bound, as a function of the input size, of the worst case number of basic operations the algorithm executes over all inputs of a fixed size.
- **Polynomial-time algorithm**: An algorithm is a polynomial-time algorithm if its expected running time is $O(k^c)$, where $k$ is the input size and $c$ is a fixed positive integer. 
- **Secure public-key encryption scheme**: A public-key encryption scheme is secure if it is semantically secure against chosen-ciphertext attacks by a computationally bounded adversary.
- **Exponential running time of an algorithm**: An exponential-time algorithm is one whose worst-case running time is not of the form $O(n^c)$ for any constant $c$, where $n$ is the input size. Fully exponential-time functions are of the form $2^{cn}$, where $c$ is a constant. Example: $O(2^{n / 2})$.
- **Subexponential running time of an algorihtm**: One whose worst-case running time function is of the form $2^{o(n)}$, and not of the form $O(n^c)$ for any constant $c$. Example: $O(2^{\sqrt n})$.
- **Security of a signature scheme**: A signature scheme is secure if it is existentially unforgeable by a computationally bounded adversary who launches a chosen-message attack.
- **Elliptic curve**: An elliptic curve $E$ over $F$, where $F = \mathbb Z_p$, $p$ is prime, or $F = \mathbb R$ is defined by an equation 

    $$
    \begin{align*}
        E/F: Y^2 = X^3 + aX + b
    \end{align*}
    $$
    where $a, b \in F$.
- **Point multiplication**: Let $P \in E(\mathbb Z_p)$ and let $k \in \mathbb N$. Then $kP = \underbrace{P + P + \cdots + P}_{k \text{ times}}$. Also, $0P = \infty$, and $(-k)P = -(kP)$.

## Symmetric-Key Encryption
### Basic Idea
The most basic form of using a Symmetric-key encryption scheme to achieve confidentiality is as follows:
1. Two parties, Alice and Bob agrees on a shared secret key $k$ by communicating over the secured channel.
2. Alice computes $c = E_k(m)$ and sends the ciphertext $c$ to Bob over the unsecured channel.
3. Bob retrieves the plaintext by decrypting the ciphertext: $m = D_k(c)$.

### Types of Attacks
1. Ciphertext-only attack: The adversary knows some ciphertext
2. Known-plaintext attack: The adversary knows some plaintext and corresponding ciphertext.
3. Chosen-plaintext attack: The adversary can choose plaintexts and obtain the corresponding ciphertexts.

Thus, for a chosen plaintext attack, the adversary breaks a SKES if she achieves the following:
1. The adversary is given a challenge ciphertext $c$.
2. The adversary can choose plaintexts $m_1, m_2, \ldots, m_q$ and obtain the corresponding ciphertexts $c_1, c_2, \ldots, c_q$.
3. The adversary obtains some information about the plaintext $m$ corresponding to $c$.

### Stream Ciphers
Stream ciphers use a pseudorandom bit generator to generate a pseudorandom sequence called the keystream. The pseudorandom sequence uses the secret key shared by Alice and Bob as the seed. The keystream is then XORed with the plaintext to produce the ciphertext.
### Block Ciphers
A block cipher is a symmetric-key encryption scheme that breaks up the plaintext into blocks of a fixed length (e.g. 128 bits) and encrypts the blocks one at a time. In contrast, a stream cipher encrypts the plaintext one bit at a time.

#### Double DES and Meet-in-the-Middle Attack
Double DES is a block cipher that encrypts the plaintext twice using two different keys, $k_1, k_2 \in_R \{0,1\}^{56}$. Encryption and decryption are done as follows:
$$
c = E_{k_2}(E_{k_1}(m)), \quad m = E_{k_1}^{-1}(E_{k_2}^{-1}(c))
$$
The main idea of the Meet-in-the-Middle attack is
$$
c = E_{k_2}(E_{k_1}(m)) \implies E_{k_2}^{-1}(c) = E_{k_1}(m)
$$
Let's outline the attack:

1. The input is 3 plaintext/ciphertext pairs $(m_1,c_1), (m_2,c_2), (m_3,c_3)$.
2. **for** each $h_2 \in \{0,1\}^{56}$
   1. Compute $E_{h_2}^{-1}(c_1)$ and store $[E_{h_2}^{-1}(c_1), h_2]$ in a table sorted by the first component.
3. **for** each $h_1 \in \{0,1\}^{56}$
   1. Compute $E_{h_1}(m_1)$.
   2. Search for the entry $[E_{h_1}(m_1), h_2]$ in the table
   3. **for** each match $[E_{h_2}^{-1}(c_1), h_2]$ in the table
      1. **if** $E_{h_2}(E_{h_1}(m_2)) = c_2$
         1. **if** $E_{h_2}(E_{h_1}(m_3)) = c_3$
            1. **return** $h_1, h_2$

So, the idea of the Meet-in-the-Middle attack is to first compute all possible $E_{k_2}^{-1}(c)$ values and store them in a table. Then compute all possible $E_{k_1}(m)$ values and search for a match in the table. If a match is found, then we check that the corresponding keys $k_1, k_2$ are correct by encrypting $m_2, m_3$ and checking if the ciphertexts match.   

#### Finite Field $GF(2^8)$
The elements of the finite field $GF(2^8)$ are the polynomials of degree at most 7 in $\mathbb Z_2[y]$, with addition and multiplication performed modulo the irreducible polynomial
$$
f(y) = y^8 + y^4 + y^3 + y + 1
$$
Then, we can interpret an 8-bit binary string $a_7a_6\ldots a_1a_0$ as coefficients of the polynomial
$$
a(y) = a_7y^7 + a_6y^6 + \cdots + a_1y + a_0
$$
So, addition is just XOR, and after multiplication, we reduce the result modulo $f(y)$ by performing long division and taking the remainder.
#### AES
AES is a block cipher that encrypts the plaintext in blocks of 128 bits. AES accepts three key lengths, 128, 192, and 256 bits. The only difference is the number of rounds used in the encryption process. The number of rounds is 10, 12, and 14 for 128, 192, and 256-bit keys, respectively. Each round uses a round key derived from the original key.
#### Block Cipher Modes of Operation
1. **ECB (Electronic Codebook)**: The plaintext is divided into blocks and each block is encrypted separately. This mode is not secure because identical plaintext blocks will produce identical ciphertext blocks.
2. **CBC (Cipher Block Chaining)**: Each plaintext block is XORed with the previous ciphertext block before encryption. The first block is XORed with a random non-secret initialization vector (IV). This mode is secure because identical plaintext blocks will produce different ciphertext blocks.

## Hash Functions
A hash function is a function that takes in an input of variable length, and outputs a message with fixed length (e.g. 256 bits). For example, SHA-256 is a hash function that outputs a 256-bit message. Hash functions are good in that a small change in the input changes the output drastically.
### Collisions, Preimages, and Second Preimages
Suppose that we have a hash function that maps the following:
$$
00 \mapsto 11, \quad 1000 \mapsto 11
$$
Then we say that $(00, 1000)$ is a collision. Moreover, $00$ is a preimage of $11$, and $1000$ is a second preimage of $00$.
### Preimage Resistance
A hash function is preimage resistant if given a hash value $y$, it is computationally infeasible to find any $x$ such that $H(x) = y$.
### Second Preimage Resistance
A hash function is second preimage resistant if given $x$, it is computationally infeasible to find another $x'$ such that $H(x) = H(x')$, so it is impossible to find another string that gives the same hash value.
### Collision Resistance
A hash function is collision resistant if it is computationally infeasible to find $x, x'$ such that $H(x) = H(x')$.

### Implications
Here is a figure of the implications of the three properties:

![Implications of Hash Function Properties](/images/school/winter-2024/co487/cr-pr-2pr-implications.png)
### Generic Attacks for Hash Functions
For finding preimages, given a hash value $y$, we just repeatedly select arbitrary $x \in_R \{0,1\}^{*}$ until $H(x) = y$. The expected number of trials is $2^n$.

For finding collisions, we select arbitrary $x \in_R \{0,1\}^{*}$ and store $(H(x), x)$ in a table sorted by first entry. We repeat until a collision is found. By the birthday paradox, the expected number of hash operations is $\sqrt{\pi \frac{2^n}{2}} \approx \sqrt{2^n}$.
### VW Parallel Collision Search
The idea is that we select an arbitrary $x_0 \in_R \{0,1\}^n$ and compute $x_i = H(x_{i-1})$ for $i \geq 1$. Then, after enough iterations, there must exist $i, j$ such that $x_i = x_j$ since there are only $N = 2^n$ possible values for $x_i$. Then $(x_{i-1}, x_{j-1})$ is a collision. To reduce storage, we only store distinguished points, which are points that have easily-testable distinguishing property, for example points with leading 32 bits all 0.

![VW Parallel Collision Search 1](/images/school/winter-2024/co487/vw1.png)

![VW Parallel Collision Search 2](/images/school/winter-2024/co487/vw2.png)

### Merkle's Meta Method for Iterated Hash Functions
We have a fixed initializing value $IV \in \{0,1\}^n$ and an efficiently computable compression function $f: \{0,1\}^{n+r} \to \{0,1\}^n$.

The idea is we break up $x$ into $r$-bit blocks, then set $H_0 = IV$. Then for $i \geq 1$, we set $H_i = f(H_{i-1}, x_i)$. The output is the last $H_i$.

Thus, the main idea is we are chaining the output of the previous hash value with the next block of the input. 
### SHA-2 Family
| Hash | Output length $n$ (bits) | Security Level |
|------|--------------------------|----------------|
| SHA-224 | 224 | 112 |
| SHA-256 | 256 | 128 |
| SHA-384 | 384 | 192 |
| SHA-512 | 512 | 256 |

## Message Authentication Codes (MAC)
A MAC scheme is a family of functions
$$
\text{MAC}_k: \{0,1\}^* \to \{0,1\}^n
$$
where $k$ is an $\ell$-bit secret key. This is used for data integrity and data origin authentication. The sender sends the message $x$, along with a computed tag $t = \text{MAC}_k(x)$. The receiver then verifies the tag by recomputing the tag and checking if it matches the received tag. If $x$ is modified in any way during transit, then the tag will be different, and the receiver can reject the message.

To break a MAC scheme, the adversary has to compute a tag for a new message that was not sent by the sender. Some generic attacks include:
- Guessing the tag of a message. So given message $x$, the adversary selects $y \in_R \{0,1\}^n$ and guess that $y = \text{MAC}_k(x)$.
- Exhaustive key search on the key space. Given $r$ message-tag pairs, the adversary can try all possible keys and check if any of them match the message-tag pairs.

### MACs based on Block Ciphers
#### CBC-MAC
For CBC-MAC, we make use of an block cipher $E_k: \{0,1\}^n \to \{0,1\}^n$. The main idea is that we break up the message $x$ into $n$-bit blocks $x_1,x_2,\ldots,x_r$. We compute
$$
H_1 = E_k(x_1), \quad H_i = E_k(H_{i-1} \oplus x_i)
$$
for $i = 2,\ldots, r$. The tag is then the last $H_r$. This is similar to Merkle's Meta Method for iterated hash functions, but instead of concatenating the output, we XOR it with the next block of the message.

CBC-MAC is secure if only fixed-length messages are allowed. If variable-length messages are allowed, then CBC-MAC is insecure. Here is an attack:
1. Select an arbitrary 3-block message $x = (x_1,x_2,x_3)$
2. Obtain the tag $t_1$ of the one-block message $x_1$, so 
   $$
   t_1 = \text{MAC}_k(x_1) = E_k(x_1)
   $$
3. Obtain the tag $t_2$ of the two-block message $(t_1 \oplus x_2, x_3)$, so
   $$
   t_2 = \text{MAC}_k(t_1 \oplus x_2, x_3) = E_k(E_k(t_1 \oplus x_2) \oplus x_3)
   $$
4. Output the forgery $(x, t_2)$

#### EMAC
One countermeasure to the attack above is to use EMAC, which stands for Encrypted CBC-MAC, where the CMC-MAC tag is encrypted using a second key $s$, so
$$
\text{EMAC}_{k, s}(x) = E_s(\text{CBC-MAC}_k(x))
$$
### MACs based on Hash Functions
HMAC is a MAC scheme that uses a hash function $H: \{0,1\}^* \to \{0,1\}^n$ and a secret key $k$. It is recommended that HMAC uses the hash function $H = \text{SHA-256}$.

HMAC is also commonly used as a key derivation function (KDF). Suppose that Alice has a secret key $k$, and wishes to derive several session keys $sk_i$ to encrypt data in different sessions. Alice then uses HMAC with $k$ to compute the session keys $sk_i$:
$$sk_1 = \text{HMAC}_k(1), \quad sk_2 = \text{HMAC}_k(2), \ldots$$

### GSM
GSM is used for 2G and 2.5G. It is used by smartphones to authenticate themselves to cell phone service providers. Suppose that Alice is a cell phone, and Bob a service provider.
1. Alice sends an authentication request to Bob
2. Bob selects a challenge $r \in_R \{0,1\}^{128}$ and sends it to Alice
3. Alice's SIM card uses $k$ (stored in the SIM card itself) to compute the response $t = \text{MAC}_k(r)$ and sends it to Bob
4. Bob verifies that $t = \text{MAC}_k(r)$
5. Alice and Bob computes an encryption key $K_E = \text{KDF}_k(r)$, and uses it to encrypt the communication between them.

Therefore, the main idea is that assuming that Alice is a valid customer with key $k$, then Alice can compute the correct response $t = \text{MAC}_k(r)$ for any challenge $r$.

## Authenticated Encryption
We want to achieve both confidentiality and authentication. Confidentiality is achieved using a symmetric key encryption scheme, for example AES-CBC. Authentication is achieved using a MAC scheme, for example HMAC. If both confidentiality and authentication are required, then we can use Encrypt-then-MAC, where the plaintext is first encrypted, then the tag is computed by MACing the ciphertext. The ciphertext and tag are then sent to the receiver. An authenticated encryption scheme $AE$ is AE-secure if $AE$ is semantically secure against chosen-plaintext attack, and $AE$ has ciphertext integrity, i.e. an adversary who is able to obtain ciphertext/tag pairs for messages of its own choosing cannot produce a valid ciphertext/tag pair for a new message.

### AES-GCM
AES-GCM is an authenticated encryption scheme that uses AES in counter mode (AES-CTR) for encryption and GMAC, a custom designed MAC scheme for authentication.

The main idea of AES-CTR is that we have a nonce, then we have a counter that keeps incrementing the nonce by 1. Each ciphertext block $C_i$ is then calculated by using AES encryption on the counter, and XORing the result with the plaintext block $M_i$. 
$$
C_i = E_k(\text{counter}) \oplus M_i
$$
Decryption is essentially the same, except that the plaintext block is calculated by using AES encryption on the counter, and XORing the result with the ciphertext block $C_i$.
$$
M_i = E_k(\text{counter}) \oplus C_i
$$
Then, AES-GCM uses AES-CTR to first encrypt the data, then computes the tag using GMAC. Note that how GMAC works is basically it generates a keystream (that depends on the nonce IV) that is the same length as the ciphertext, so it acts as like a one time pad for the ciphertext.

Therefore, it is important to never reuse the nonce IV, otherwise the keystream will be the same. Once Eve receives two ciphertexts with the same nonce IV, she can XOR the two ciphertexts to obtain the XOR of the two plaintexts, which does not depend on the key.
### AWS
The main idea is that each customer has a Customer Main Key (CMK) that is stored in HSMs, which are dedicated devices in AWS to store keys. The CMK is used to encrypt the data encryption key (DEK) that is used to encrypt the data. Each piece of data is encrypted with a different DEK.

## Public-Key Cryptography
In public-key cryptography, communicating parties share some authenticated (but non-secret) information. Thus, each entity has a private/public key pair. In general, public-key cryptography works as follows.

To send a message $m$ to Bob, Alice does the following:
1. Obtain an authentic copy of Bob's public key $P_B$
2. Encrypt the message $m$ using Bob's public key $P_B$ to obtain the ciphertext $c = E(P_B, m)$
3. Send the ciphertext $c$ to Bob

Then to decrypt the message, Bob does the following:
1. Use his private key $S_B$ to decrypt the ciphertext $c$ to obtain the message $m = D(S_B, c)$

To sign a message $m$, Alice does the following:
1. User her private key $S_A$ to sign the message $m$ to obtain the signature $s = \text{Sign}(S_A, m)$
2. Send the message $m$ and the signature $s$ to Bob

Then to verify the signature, Bob does the following:
1. Obtain an authentic copy of Alice's public key $P_A$
2. Verify the signature $s$ on the message $m$ using Alice's public key $P_A$ to obtain the result $r = \text{Verify}(P_A, m, s)$
3. Accept the message $m$ if $r = \text{Accept}$, otherwise reject the message

### Hybrid Schemes
One disadvantage of public-key cryptography is that it is slow when compared to symmetric-key cryptography. Therefore, the most common approach is to use public key cryptography to obtain a secret key used for symmetric-key cryptography.

### Repeated Square-and-Multiply
Suppose that we want to compute $a^m \mod n$. We can write $m$ in binary form, $m = 2^{m_1} + 2^{m_2} + \cdots + 2^{m_{r-1}} + 2^{m_r}$. Then we can compute $a^{2^i} \mod n$ for $i = 0,1,\ldots,r$ and simply multiply them together to get $a^m \mod n$.

As an example, consider $a^{137} \mod n$. We can write $137$ in binary: 
$$
137 = 2^7 + 2^3 + 2^0 
$$
and we can write
$$
a^{137} = a^{2^7} \cdot a^{2^3} \cdot a^{2^0}
$$
Then compute
$$
a, a^2 \mod n, a^{2^2} \mod n, a^{2^3} \mod n, \ldots, \quad a^{2^7} \mod n
$$
Finally, we can multiply:
$$
a \cdot a^8 \cdot a^{128} \mod n = a^{137} \mod n
$$

## RSA Public-Key Cryptography
### Basic RSA Encryption Scheme
#### Key Generation
Each entity does the following to generate a public/private key pair:
1. Randomly select two large distinct primes $p, q$ of the same bitlength
2. Compute $n = pq$ and $\phi = (p-1)(q-1)$. $n$ is called the RSA modulus.
3. Select an arbitrary integer $e$ with $1 < e < \phi$ and $\gcd(e, \phi) = 1$. $e$ is called the encryption exponent.
4. Compute $d = e^{-1} \mod \phi$. $d$ is called the decryption exponent. This can be done using the Extended Euclidean Algorithm.
5. The public key is $(n, e)$ and the private key is $d$.

#### Encryption
Suppose that $B$ wants to send a message $m$ to $A$.
1. Obtain $A$'s public key $(n, e)$
2. Compute the ciphertext $c = m^e \mod n$ using repeated square and multiply.
3. Send $c$ to $A$

#### Decryption
$A$ decrypts the ciphertext $c$ as follows:
1. Compute $m = c^d \mod n$

#### Security of RSA Encryption
If an adversary can factor $n$, she can compute the private key $d$ from the public key $(n,e)$. A basic notion of security is that it should be computationally infeasible to compute plaintext $m$ from ciphertext $c$. This is known as the RSA problem.

#### Dictionary Attack
If the plaintext $m$ is chosen from a relatively small set $M$ of messages, then the adversary can launch a dictionary attack. Given a target ciphertext $c$, the adversary can compute all $m \in M$ until $c$ is obtained. So, the adversary can simply create a dictionary of all $(m, c)$ pairs, and when she receives a new ciphertext $c'$, she can look up the dictionary to find the corresponding plaintext $m'$.

A countermeasure is to append a randomly selected 128-bit string (called a salt) to $m$ prior to encryption
$$
m' = \text{salt} \| m
$$
So, $m$ is now encrypted to one of $2^{128}$ possible ciphertexts, so a dictionary attack is infeasible.

#### Chosen-ciphertext Attack
Suppose that the adversary has a ciphertext $c$. The adversary can obtain the plaintext $m$ as follows:
1. Select arbitrary $x \in [2, n - 1]$ with $\gcd(x, n) = 1$. Note that $\gcd(x, n) \neq 1$ implies that the GCD is either $p, q$, or $n$ since $n$ is prime. It cannot be $n$ since $x < n - 1$. If it is $p$ or $q$, then the adversary is lucky and she can factor $n$. So let's assume $\gcd = 1$.
2. Compute $\hat c = c x^e \mod n$, where $(n, e)$ is $A$'s public key.
3. Obtain the decryption $\hat m$ from the oracle. So we get
$$
\hat m \equiv \hat c^d \equiv (c x^e)^d \equiv c^d x^{ed} \equiv c^d x \equiv m x \mod n
$$
That is, $\hat m = m x \mod n$.
4. Compute $x^{-1} \mod n$ using the Extended Euclidean Algorithm. Multiply the equation above by $x^{-1}$ to obtain $m = \hat m x^{-1} \mod n$.

A countermeasure to this attack is add some prescribed formatting to $m$ prior to encryption. So, after decrypting the ciphertext $c$, if the plaintext is not properly formatted, then $A$ rejects $c$ and does not return a plaintext. This way, the adversary cannot obtain the plaintext $\hat m$.

### Basic RSA Signature Scheme
#### Key Generation
Key generation is exactly the same as the encryption scheme.
1. Randomly select two large distinct primes $p, q$ of the same bitlength
2. Compute $n = pq$ and $\phi = (p-1)(q-1)$. $n$ is called the RSA modulus.
3. Select an arbitrary integer $e$ with $1 < e < \phi$ and $\gcd(e, \phi) = 1$. $e$ is called the encryption exponent.
4. Compute $d = e^{-1} \mod \phi$. $d$ is called the decryption exponent. This can be done using the Extended Euclidean Algorithm.
5. The public key is $(n, e)$ and the private key is $d$.

#### Signature Generation
Suppose that $A$ wants to sign a message $m$.
1. Hash the message $m$ to obtain $M = H(m)$
2. Compute $s = M^d \mod n$
3. Send the signature $s$ to $B$

This works because if we raise $s$ to the power of $e$, we get
$$
s^e \equiv M^{de} \equiv M \mod n
$$
since $ed = 1$.
#### Signature Verification
To verify a message $m$ with signature $s$, $B$ does the following:
1. Obtain an authentic copy of $A$'s public key $(n, e)$
2. Compute $M = H(m)$
3. Compute $M' = s^e \mod n$
4. Accept if $M' = M$, otherwise reject

#### Requirements for Hash Function
##### Preimage Resistance
The hash function $H$ must be preimage resistant. If $H$ is not preimage resistant, then signatures can be forged as follows:
1. Select $s \in_R [0, n - 1]$ and compute $M = s^e \mod n$
2. Find the preimage of $M$ under $H$, so find $m$ such that $H(m) = M$
3. Then $s$ is a valid signature for $m$.

##### Second Preimage Resistance
The hash function $H$ must be second preimage resistant. If $H$ is not second preimage resistant, then signatures can be forged as follows:
1. Suppose that $(m, s)$ is a valid signed message
2. Find an $m'$ with $m' \neq m$ such that $H(m') = H(m)$
3. Then $(m', s)$ is a valid signed message.

##### Collision Resistance
The hash function $H$ must be collision resistant. If $H$ is not collision resistant, then signatures can be forged as follows:
1. Select $m_1, m_2$ with $m_1 \neq m_2$ and $H(m_1) = H(m_2)$
2. Induce $A$ to sign $m_1$ to obtain $s = H(m_1)^d \mod n$
3. $s$ is also a valid signature for $m_2$.

### PKCS #1 v1.5 RSA Signature Scheme
#### Signature Generation
The main idea is that we hash the message $m$ to obtain $h = H(m)$, then we format $h$ to obtain $M$ as follows:
$$
M = 00 \mathbin\| 01 \mathbin\| \text{FF} \ldots \text{FF} \mathbin\| 00 \mathbin\| \text{hash name} \mathbin\| h
$$
where $M$ has the same length as $n$.
#### Signature Verification
1. Obtain an authentic copy of $A$'s public key $(n, e)$
2. Compute $M = s^e \mod n$, and write $M$ as a string of $k$ bytes, where $k$ is the bytelength of $n$
3. Check the formatting of $M$ to ensure that it is of the form $00 \mathbin\| 01 \mathbin\| \text{FF} \ldots \text{FF} \mathbin\| 00 \mathbin\| \text{hash name} \mathbin\| h$
4. Obtain the hash name and $h$.
5. Compute $h' = H(m)$
6. Accept if $h' = h$, otherwise reject

#### Bleichenbacher's Attack
The above signature scheme is vulnerable to Bleichenbacher's attack if the formatting check is not done properly. The main idea is that the adversary can forge a signature by sending a carefully crafted message to the verifier such that when the verifier applies the exponent $e$ to the signature $s$, the result will be a string that has proper formatting, and thus the verifier will accept the signature. Therefore, the adversary never needs to know the private key $d$ in order to forge a signature.

## Elliptic Curve Cryptography
An elliptic curve over $F$ is defined by an equation
$$
E/F: Y^2 = X^3 + aX + b
$$
And the set of $F$-rational points on $E$ is
$$
E(F) = \{(x, y) \in F \times F: y^2 = x^3 + ax + b\} \cup \{\infty\}
$$
where $\infty$ is a special point called the point at infinity.

Now, all $x$ coordinates give at most two $y$ coordinates, so the number of points in $E(\mathbb Z_p)$ is at most $2p + 1$ (accounting for $\infty$). By Hasse's Theorem, we have
$$
\# E(\mathbb Z_p) \approx p
$$
### Point Addition
Let $P, Q \in E(\mathbb R)$. Let $\ell$ denote the straight line through $P$ and $Q$. Let $T \in E(\mathbb R)$ be the third point of intersection of $\ell$ with the elliptic curve. Then $P + Q$ is the reflection of $T$ in the $x$-axis. Here are the four rules for point addition:
1. $P + \infty = \infty + P = P$ for all $P \in E(\mathbb R)$
2. If $P = (x, y) \in E(F)$, then $-P = (x, -y)$, also $-\infty = \infty$. Then their sum is
$$
P + (-P) = -P + P = \infty
$$
3. If $P = (x_1, y_1)$ and $Q = (x_2, y_2)$, and $P \neq \pm Q$. Then $P + Q = (x_3, y_3)$, where
$$
x_3 = \lambda^2 - x_1 - x_2, \quad y_3 = -y_1 + \lambda(x_1 - x_3), \quad \lambda = \frac{y_2 - y_1}{x_2 - x_2}
$$
4. Let $P = (x_1, y_1)$, and $P \neq -P$. Then $P + P = (x_3, y_3)$, where
$$
x_3 = \lambda^2 - 2x_1, \quad y_3 = -y_1 + \lambda(x_1 - x_3), \quad \lambda = \frac{3x_1^2 + a}{2y_1}
$$
### Point Multiplication
Let $P \in E(\mathbb Z_p)$ and let $k \in \mathbb N$. Then
$$
kP = \underbrace{P + P + \cdots + P}_{k \text{ times}}
$$
Also, $0P = \infty$, and $(-k)P = -(kP)$.
### Generator
Suppose $n = \# E(\mathbb Z_p)$. Let $P \in E(\mathbb Z_p)$ that is not $\infty$. If $nP = \infty$, and the points $\infty, P, 2P,\ldots, (n-1)P$ are distinct, then $P$ is called a generator of $E(\mathbb Z_p)$.
### Elliptic Curve Discrete Logarithm Problem (ECDLP)
Let $P, Q \in E(\mathbb Z_p)$ be two points. Finding $\ell \in [0, n - 1]$ where $\ell$ is an integer such that $Q = \ell P$ is called the ECDLP. The integer $\ell$ is called the discrete logarithm of $Q$ to the base $P$, written $\ell = \log_P Q$.

Here are some algorithms for solving the ECDLP:
1. **Brute force**. Compute $P, 2P, 3P, \ldots$ until $Q$ is encountered. The running time of this attack is $O(n)$ point additions, or $O(p)$ point additions since $n \approx p$ by Hasse's theorem. Since the input size is $\log p$, meaning $p \approx 2^{\log p}$, we have $O(2^{\log p})$ point additions, which is fully-exponential.
2. **Shanks' Algorithm**. This is a meet-in-the-middle attack. The main idea is that let $m = \lceil \sqrt n \rceil$, then by division algorithm, we have
   $$
   \ell = qm + r \implies \ell - qm = r
   $$
   Multiplying both sides by $P$ gives
   $$
   \ell P - qmP = rP
   $$
   We let $M = mP$, and since $Q = \ell P$, we can rewrite as
   $$
   Q - qM = rP
   $$
   Then we loop through $r = 0,1,\ldots,m-1$ and compute $rP$ and store it in a table. Then we loop through $q = 0,1,\ldots,m-1$ and compute $Q - qM$ and check if it is in the table. If it is, then we have found $\ell$.
3. **Pollard's Algorithm**. Just remember the running time is $\approx \sqrt p$ point additions.
   
### Elliptic Curve Diffie-Hellman (ECDH)
ECDH is a key exchange protocol. Suppose that Alice and Bob want to agree on a shared secret key $k$.
1. Alice selects $x \in_R [1, n - 1]$ and computes $X = xP$, then sends $X$ to Bob.
2. Bob selects $y \in_R [1, n - 1]$ and computes $Y = yP$, then sends $Y$ to Alice.
3. Alice computes $K = yX$ and $k = KDF(K)$
4. Bob computes $K = xY$ and $k = KDF(K)$

$X, Y$ are now Alice and Bob's public keys, and $x, y$ are their private keys. The shared secret key $k$ is the same for both Alice and Bob since
$$
yX = y(xP) = x(yP) = xY
$$
However, this is susceptible to the MITM attack.

![ECDH MITM Attack](/images/school/winter-2024/co487/ECDH-MITM.png)

The solution is to use authenticated ECDH. Alice and Bob authenticate each other's public keys using ECDSA.
### Elliptic Curve Digital Signature Algorithm (ECDSA)
We have the following domain parameters
- Elliptic curve $E$, defined over $\mathbb Z_p$ with $n = \# E(\mathbb Z_p)$ prime
- A generator $P \in E(\mathbb Z_p)$
- A collision resistant hash function $H$ whose output has the same bitlength as $n$.

#### Key Generation
1. Select $a \in_R [1, n - 1]$ and compute $A = aP$
2. Alice's private key is $a$ and the public key is $A$

#### Signature Generation
Suppose that Alice wants to sign a message $M$.
1. Compute $m = H(M)$ and interpret $m$ as an integer
2. Select a per-message secret key $k \in_R [1, n - 1]$
3. Compute $R = kP$. Let $r = x(R)$ be the x-coordinate of $R$ modulo $n$. Check that $r \neq 0$
4. Compute $s = k^{-1}(m + ar) \mod n$ and check that $s \neq 0$
5. Alice's signature on $M$ is $(r, s)$

Note that a fresh $k$ should be used for each signature.

#### Signature Verification
Suppose that Bob receives a message $M$ with signature $(r, s)$.
1. Obtain an authentic copy of Alice's public key $A$
2. Check that $r, s$ are integers in $[1, n - 1]$
3. Compute $m = H(M)$
4. Compute $u_1 = ms^{-1} \mod n$ and $u_2 = rs^{-1} \mod n$
5. Compute $V = u_1 P + u_2 A$ and verify that $V \neq \infty$
6. Compute $v = x(V) \mod n$
7. Accept the signature if $v = r$, otherwise reject

Let's see why this works. Given $M, (r, s)$ and $A$, we need to verify that $s = k^{-1} (m + ar) \mod n$. We have
$$
\begin{align*}
   s &= k^{-1} (m + ar) \mod n \tag*{$\iff$} \\
   k &\equiv s^{-1} (m + ar) \pmod n \tag*{$\iff$} \\
   k \equiv \underbrace{s^{-1}m}_{u_1} + \underbrace{(s^{-1}r)}_{u_2} a \pmod n \tag*{$\iff$} \\
   kP &= u_1 P + u_2 a P \tag*{$\iff$} \\
   R &= u_1 P + u_2 aP \tag*{$\iff$} \\
   R &= u_1 P + u_2 A
\end{align*}
$$
Now, $u_1 = s^{-1}m$ is known, and $u_2 = s^{-1}r$ is known. So $R = u_1 P + u_2 A$ is known and can be computed. Then we compute $v = x(R) \mod n$ and check if $v = r$.

## Bluetooth Security
When two bluetooth devices pair, there are 5 phases
1. **Public Key Exchange**: Establish an (unauthenticated) shared secret
2. **Authentication stage 1**: Provide some protection against active MITM attacks
3. **Authentication stage 2**: Confirm that both devices have successfully completed the exchange and confirm the Bluetooth addresses
4. **Link Key calculation**: Compute the long term link key
5. **Authentication and Encryption**: Check that the communicating devices hold the same link key (and thus are paired) and then derive a shared secret encryption key $K_E$, which is used to encrypt and authenticate data for that session.

The details of each phase are not that important, and do not need to be memorized.

## Key Management
One techniques for distributing public keys over the internet is by offline certification authorities (CAs).
### Certificate Authority (CA)
A CA issues certificates that bind an entity's identity $A$ to its public key. $A$'s certificate $\text{Cert}_A$ consists of
- Data part $D_A$: contains $A$'s identity, her public key, and other information such as validity period.
- Signature part $S_{CA}$: The CA's signature on $D_A$.

Then another party $B$ obtains an authentic copy of $A$'s public key as follows:
1. Obtain an authentic copy of CA's public key
2. Obtain $\text{Cert}_A$ from the CA 
3. Verify the CA's signature $S_{CA}$ on $D_A$ using the CA's public key

### Transport Layer Security (TLS)
The main components of TLS are
1. Handshake protocol: Allows the server to authenticate itself to the client, and then negotiate cryptographic keys.
2. Record protocol: Used to encrypt and authenticate transmitted data for the remainder of the session.

#### Handshake Protocol
There are four phases in the handshake protocol:
1. **Establish Security capabilities**: This negotiates protocol version, cryptographic algorithms, security levels, etc.
2. **Server authentication and key exchange**: The server sends its certificate, and key exchange parameters
3. **Client authentication and key exchange**: Client sends its certificate and key exchange parameters
4. **Finish**: Both parties send a finished message to confirm that the handshake is complete.

There are two main key establishment schemes in the handshake protocol:
1. **RSA key transport**: The shared secret key $k$ is selected by the client and encrypted with the server's RSA public key.
2. **Elliptic Curve Diffie-Hellman (ECDH)**: The server selects a one time ECDH public key $X = xP$ and signs it with its RSA or ECDSA signature key. The client also selects a one time ECDH public key $Y = yP$. The session key $k$ is then $k = KDF(xyP)$.

The main advantage of ECDH over RSA key transport is that it provides forward secrecy. If the server's RSA private key is compromised, then all past sessions are compromised. However, if the server's ECDH private key is compromised, then only the current session is compromised.