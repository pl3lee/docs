# CO487 - Applied Cryptography
This page is a condensed version of the course notes for CO487. It is intended to be a quick reference for the course material in order to help me study for the final exam.
## Definitions
Here are some terms and concepts that we are expected to memorize
- **Confidentiality**: Keeping data secret from all but those authorized to see it.
- **Data integrity**: Ensuring data has not been altered by unauthorized means, meaning the data has not been modified or tampered with.
- **Data origin authentication**: Corroborating the source of data, meaning that the data is from the source it claims to be from.
- **Non-repudiation**: Preventing an entity from denying previous commitments or actions.
- **Totally Insecure**: Given a symmetric key encryption scheme, if an adversary can recover the secret key $k$, or systematically recover plaintext from ciphertext, without necessarily learning $k$, then the scheme is said to be totally insecure (or totally broken).
- **Semantically Secure**: If the adversary cannot learn any partial information about the plaintext from the ciphertext (except possibly its length), the encryption scheme is said to be semantically secure.
- **Secure symmetric-key encryption scheme**: A symmetric-key encryption scheme is secure if it is semantically secure against chosen-plaintext attack by a computationally bounded adversary.
- **Security level of a cryptographic scheme**: A cryptographic scheme is said to have a security level of $\ell$ bits if the fastest known attack on the scheme takes approximately $2^\ell$ operations.
- **Preimage-resistant hash function**: A hash function $H: \{0,1\}^* \to \{0,1\}^n$ is preimage resistant if, given a hash value $y \in_R \{0,1\}^n$, it is computationally infeasible to find any $x \in \{0,1\}^*$ with $H(x) = y$ ($x$ is called a preimage of $y$). That is, given $y$, it is almost impossible to find the preimage.
- **Second-preimage resistant hash function**: A hash function $H: \{0,1\}^* \to \{0,1\}^n$ is 2nd preimage resistant if given $x \in_R \{0,1\}^*$, it is computationally infeasible to find another $x' \in \{0,1\}^*$, where $x \neq x'$, such that $H(x) = H(x')$. That is, it is impossible to find another string that has the same hash value.
- **Collision-resistant hash function**: A hash function $H: \{0,1\}^* \to \{0,1\}^n$ is collision resistant if it is computationally infeasible to find $x, x' \in \{0,1\}^*$ with $x \neq x'$ such that $H(x) = H(x')$. Such a pair $(x,x')$ is called a collision.
- **Secure MAC scheme**: A MAC scheme is secure if given some tags $\text{MAC}_k(x_i)$ for messages $x_i'$s of one's own choosing, it is computationally infeasible to compute a message-tag pair $(x, \text{MAC}_k(x))$ for a new message $x$. More concisely, a MAC scheme is secure if it is existentially unforgeable against chosen-message attack.
- **Secure authenticated encryption scheme**: An authenticated encryption scheme $AE$ is AE-secure if $AE$ is semantically secure against chosen-plaintext attack, and $AE$ has ciphertext integrity, i.e. an adversary who is able to obtain ciphertext/tag pairs for messages of its own choosing cannot produce a valid ciphertext/tag pair for a new message.
- **Input size**: The input size is the number of bits required to write down the input using a reasonable encoding.
- **Running time of an algorithm**: The running time of an algorithm is an upper bound, as a function of the input size, of the worst case number of basic operations the algorithm executes over all inputs of a fixed size.
- **Polynomial-time algorithm**: An algorithm is a polynomial-time algorithm if its expected running time is $O(k^c)$, where $k$ is the input size and $c$ is a fixed positive integer. 
- **Secure public-key encryption scheme**: A public-key encryption scheme is secure if it is semantically secure against chosen-ciphertext attacks by a computationally bounded adversary.
- **Exponential running time of an algorithm**: An exponential-time algorithm is one whose worst-case running time is not of the form $O(n^c)$ for any constant $c$, where $n$ is the input size. Fully exponential-time functions are of the form $2^{cn}$, where $c$ is a constant. Example: $O(2^{n / 2})$.
- **Subexponential running time of an algorihtm**: One whose worst-case running time function is of the form $2^{o(n)}$, and not of the form $O(n^c)$ for any constant $c$. Example: $O(2^{\sqrt n})$.
- **Security of a signature scheme**: A signature scheme is secure if it is existentially unforgeable by a computationally bounded adversary who launches a chosen-message attack.
- **Elliptic curve**: An elliptic curve $E$ over $F$, where $F = \mathbb Z_p$, $p$ is prime, or $F = \mathbb R$ is defined by an equation 

    $$
    \begin{align*}
        E/F: Y^2 = X^3 + aX + b
    \end{align*}
    $$
    where $a, b \in F$.
- **Point multiplication**: Let $P \in E(\mathbb Z_p)$ and let $k \in \mathbb N$. Then $kP = \underbrace{P + P + \cdots + P}_{k \text{ times}}$. Also, $0P = \infty$, and $(-k)P = -(kP)$.

## Symmetric-Key Encryption
### Basic Idea
The most basic form of using a Symmetric-key encryption scheme to achieve confidentiality is as follows:
1. Two parties, Alice and Bob agrees on a shared secret key $k$ by communicating over the secured channel.
2. Alice computes $c = E_k(m)$ and sends the ciphertext $c$ to Bob over the unsecured channel.
3. Bob retrieves the plaintext by decrypting the ciphertext: $m = D_k(c)$.

### Types of Attacks
1. Ciphertext-only attack: The adversary knows some ciphertext
2. Known-plaintext attack: The adversary knows some plaintext and corresponding ciphertext.
3. Chosen-plaintext attack: The adversary can choose plaintexts and obtain the corresponding ciphertexts.

Thus, for a chosen plaintext attack, the adversary breaks a SKES if she achieves the following:
1. The adversary is given a challenge ciphertext $c$.
2. The adversary can choose plaintexts $m_1, m_2, \ldots, m_q$ and obtain the corresponding ciphertexts $c_1, c_2, \ldots, c_q$.
3. The adversary obtains some information about the plaintext $m$ corresponding to $c$.

### Stream Ciphers
Stream ciphers use a pseudorandom bit generator to generate a pseudorandom sequence called the keystream. The pseudorandom sequence uses the secret key shared by Alice and Bob as the seed. The keystream is then XORed with the plaintext to produce the ciphertext.
### Block Ciphers
A block cipher is a symmetric-key encryption scheme that breaks up the plaintext into blocks of a fixed length (e.g. 128 bits) and encrypts the blocks one at a time. In contrast, a stream cipher encrypts the plaintext one bit at a time.

#### Double DES and Meet-in-the-Middle Attack
Double DES is a block cipher that encrypts the plaintext twice using two different keys, $k_1, k_2 \in_R \{0,1\}^{56}$. Encryption and decryption are done as follows:
$$
c = E_{k_2}(E_{k_1}(m)), \quad m = E_{k_1}^{-1}(E_{k_2}^{-1}(c))
$$
The main idea of the Meet-in-the-Middle attack is
$$
c = E_{k_2}(E_{k_1}(m)) \implies E_{k_2}^{-1}(c) = E_{k_1}(m)
$$
Let's outline the attack:

1. The input is 3 plaintext/ciphertext pairs $(m_1,c_1), (m_2,c_2), (m_3,c_3)$.
2. **for** each $h_2 \in \{0,1\}^{56}$
   1. Compute $E_{h_2}^{-1}(c_1)$ and store $[E_{h_2}^{-1}(c_1), h_2]$ in a table sorted by the first component.
3. **for** each $h_1 \in \{0,1\}^{56}$
   1. Compute $E_{h_1}(m_1)$.
   2. Search for the entry $[E_{h_1}(m_1), h_2]$ in the table
   3. **for** each match $[E_{h_2}^{-1}(c_1), h_2]$ in the table
      1. **if** $E_{h_2}(E_{h_1}(m_2)) = c_2$
         1. **if** $E_{h_2}(E_{h_1}(m_3)) = c_3$
            1. **return** $h_1, h_2$

So, the idea of the Meet-in-the-Middle attack is to first compute all possible $E_{k_2}^{-1}(c)$ values and store them in a table. Then compute all possible $E_{k_1}(m)$ values and search for a match in the table. If a match is found, then we check that the corresponding keys $k_1, k_2$ are correct by encrypting $m_2, m_3$ and checking if the ciphertexts match.   

#### Finite Field $GF(2^8)$
The elements of the finite field $GF(2^8)$ are the polynomials of degree at most 7 in $\mathbb Z_2[y]$, with addition and multiplication performed modulo the irreducible polynomial
$$
f(y) = y^8 + y^4 + y^3 + y + 1
$$
Then, we can interpret an 8-bit binary string $a_7a_6\ldots a_1a_0$ as coefficients of the polynomial
$$
a(y) = a_7y^7 + a_6y^6 + \cdots + a_1y + a_0
$$
So, addition is just XOR, and after multiplication, we reduce the result modulo $f(y)$ by performing long division and taking the remainder.
#### AES
AES is a block cipher that encrypts the plaintext in blocks of 128 bits. AES accepts three key lengths, 128, 192, and 256 bits. The only difference is the number of rounds used in the encryption process. The number of rounds is 10, 12, and 14 for 128, 192, and 256-bit keys, respectively. Each round uses a round key derived from the original key.
#### Block Cipher Modes of Operation
1. **ECB (Electronic Codebook)**: The plaintext is divided into blocks and each block is encrypted separately. This mode is not secure because identical plaintext blocks will produce identical ciphertext blocks.
2. **CBC (Cipher Block Chaining)**: Each plaintext block is XORed with the previous ciphertext block before encryption. The first block is XORed with a random non-secret initialization vector (IV). This mode is secure because identical plaintext blocks will produce different ciphertext blocks.

## Hash Functions
A hash function is a function that takes in an input of variable length, and outputs a message with fixed length (e.g. 256 bits). For example, SHA-256 is a hash function that outputs a 256-bit message. Hash functions are good in that a small change in the input changes the output drastically.
### Collisions, Preimages, and Second Preimages
Suppose that we have a hash function that maps the following:
$$
00 \mapsto 11, \quad 1000 \mapsto 11
$$
Then we say that $(00, 1000)$ is a collision. Moreover, $00$ is a preimage of $11$, and $1000$ is a second preimage of $00$.
### Preimage Resistance
A hash function is preimage resistant if given a hash value $y$, it is computationally infeasible to find any $x$ such that $H(x) = y$.
### Second Preimage Resistance
A hash function is second preimage resistant if given $x$, it is computationally infeasible to find another $x'$ such that $H(x) = H(x')$, so it is impossible to find another string that gives the same hash value.
### Collision Resistance
A hash function is collision resistant if it is computationally infeasible to find $x, x'$ such that $H(x) = H(x')$.

### Implications
Here is a figure of the implications of the three properties:

![Implications of Hash Function Properties](/images/school/winter-2024/co487/cr-pr-2pr-implications.png)
### Generic Attacks for Hash Functions
For finding preimages, given a hash value $y$, we just repeatedly select arbitrary $x \in_R \{0,1\}^{*}$ until $H(x) = y$. The expected number of trials is $2^n$.

For finding collisions, we select arbitrary $x \in_R \{0,1\}^{*}$ and store $(H(x), x)$ in a table sorted by first entry. We repeat until a collision is found. By the birthday paradox, the expected number of hash operations is $\sqrt{\pi \frac{2^n}{2}} \approx \sqrt{2^n}$.
### VW Parallel Collision Search
The idea is that we select an arbitrary $x_0 \in_R \{0,1\}^n$ and compute $x_i = H(x_{i-1})$ for $i \geq 1$. Then, after enough iterations, there must exist $i, j$ such that $x_i = x_j$ since there are only $N = 2^n$ possible values for $x_i$. Then $(x_{i-1}, x_{j-1})$ is a collision. To reduce storage, we only store distinguished points, which are points that have easily-testable distinguishing property, for example points with leading 32 bits all 0.

![VW Parallel Collision Search 1](/images/school/winter-2024/co487/vw1.png)

![VW Parallel Collision Search 2](/images/school/winter-2024/co487/vw2.png)

### Merkle's Meta Method for Iterated Hash Functions
We have a fixed initializing value $IV \in \{0,1\}^n$ and an efficiently computable compression function $f: \{0,1\}^{n+r} \to \{0,1\}^n$.

The idea is we break up $x$ into $r$-bit blocks, then set $H_0 = IV$. Then for $i \geq 1$, we set $H_i = f(H_{i-1}, x_i)$. The output is the last $H_i$.

Thus, the main idea is we are chaining the output of the previous hash value with the next block of the input. 
### SHA-2 Family
| Hash | Output length $n$ (bits) | Security Level |
|------|--------------------------|----------------|
| SHA-224 | 224 | 112 |
| SHA-256 | 256 | 128 |
| SHA-384 | 384 | 192 |
| SHA-512 | 512 | 256 |

## Message Authentication Codes (MAC)
A MAC scheme is a family of functions
$$
\text{MAC}_k: \{0,1\}^* \to \{0,1\}^n
$$
where $k$ is an $\ell$-bit secret key. This is used for data integrity and data origin authentication. The sender sends the message $x$, along with a computed tag $t = \text{MAC}_k(x)$. The receiver then verifies the tag by recomputing the tag and checking if it matches the received tag. If $x$ is modified in any way during transit, then the tag will be different, and the receiver can reject the message.

To break a MAC scheme, the adversary has to compute a tag for a new message that was not sent by the sender. Some generic attacks include:
- Guessing the tag of a message. So given message $x$, the adversary selects $y \in_R \{0,1\}^n$ and guess that $y = \text{MAC}_k(x)$.
- Exhaustive key search on the key space. Given $r$ message-tag pairs, the adversary can try all possible keys and check if any of them match the message-tag pairs.

### MACs based on Block Ciphers
#### CBC-MAC
For CBC-MAC, we make use of an block cipher $E_k: \{0,1\}^n \to \{0,1\}^n$. The main idea is that we break up the message $x$ into $n$-bit blocks $x_1,x_2,\ldots,x_r$. We compute
$$
H_1 = E_k(x_1), \quad H_i = E_k(H_{i-1} \oplus x_i)
$$
for $i = 2,\ldots, r$. The tag is then the last $H_r$. This is similar to Merkle's Meta Method for iterated hash functions, but instead of concatenating the output, we XOR it with the next block of the message.

CBC-MAC is secure if only fixed-length messages are allowed. If variable-length messages are allowed, then CBC-MAC is insecure. Here is an attack:
1. Select an arbitrary 3-block message $x = (x_1,x_2,x_3)$
2. Obtain the tag $t_1$ of the one-block message $x_1$, so 
   $$
   t_1 = \text{MAC}_k(x_1) = E_k(x_1)
   $$
3. Obtain the tag $t_2$ of the two-block message $(t_1 \oplus x_2, x_3)$, so
   $$
   t_2 = \text{MAC}_k(t_1 \oplus x_2, x_3) = E_k(E_k(t_1 \oplus x_2) \oplus x_3)
   $$
4. Output the forgery $(x, t_2)$

#### EMAC
One countermeasure to the attack above is to use EMAC, which stands for Encrypted CBC-MAC, where the CMC-MAC tag is encrypted using a second key $s$, so
$$
\text{EMAC}_{k, s}(x) = E_s(\text{CBC-MAC}_k(x))
$$
### MACs based on Hash Functions
HMAC is a MAC scheme that uses a hash function $H: \{0,1\}^* \to \{0,1\}^n$ and a secret key $k$. It is recommended that HMAC uses the hash function $H = \text{SHA-256}$.

HMAC is also commonly used as a key derivation function (KDF). Suppose that Alice has a secret key $k$, and wishes to derive several session keys $sk_i$ to encrypt data in different sessions. Alice then uses HMAC with $k$ to compute the session keys $sk_i$:
$$sk_1 = \text{HMAC}_k(1), \quad sk_2 = \text{HMAC}_k(2), \ldots$$

### GSM
