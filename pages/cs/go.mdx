import { FileTree } from 'nextra/components'

# GO
Notes taken from [this](https://youtu.be/8uiZC0l4Ajw?si=v7CxSfCoaZqs08Yu) video.
## Six Main Points about GO
- It is a statically typed language. This means that the type of a variable is either explicitly declared or inferred by the compiler. The type of a variable cannot change after itâ€™s declared.
- It is a strongly typed language. This means that an operation you can perform on a variable depends on its type. For example, you cannot add a string to an integer.
- GO is compiled, so after compiling, it can output into a standalone executable file, for example `.exe` for Windows. This also results in a faster execution time.
- GO has fast compile times.
- GO has built in concurrency support. This is done with Goroutines.
- Simplicity, its syntax is simple and it has garbage collection for memory management.

## Introduction
There are two concepts in GO, **packages** and **modules**.

A package is just a folder that contains a collection of GO files. 

A module is a collection of packages. So when we initialize a project, we are creating a module.

When we initialize our project/module, we can use the command
```bash
go mod init <module_name>
```
Most commonly the module name is a link to the repository where the code is stored. This creates a `go.mod` file in the root of the project. We see that it contains the following:
```go
module github.com/username/repo_name

go 1.20
```
So it contains the module name and the version of GO that we are using. Let's create a `cmd` directory, and inside it, a `tutorial_1` directory, and inside that, a `main.go` file. 

<FileTree>
    <FileTree.File name="go.mod"/>
    <FileTree.Folder name="cmd">
        <FileTree.Folder name="tutorial_1">
            <FileTree.File name="main.go"/>
        </FileTree.Folder>
    </FileTree.Folder>
</FileTree>
Recall that every GO file is part of a package. We identify the package it belongs to by the first line of the file. For example, in `main.go` we have:
```go
package main
```
This is a special package name that tells the compiler to look for the entrypoint function here. The entrypoint function is `main()`, which is the first thing that gets executed when we run the program. To create a function, we use the `func` keyword, followed by the name of the function, and then the parameters in parentheses.
```go
package main

func main() {
    // code here
}
```
Let's try to print to our console. We need the `fmt` package to do this. We can import it by using the `import` keyword, followed by the package name in double quotes.
```go
package main
import "fmt"

func main() {
    // Println appends a newline character to the end of the string
    fmt.Println("Hello, World!")
}
```
To run the program, we use the command `go build cmd/tutorial_1/main.go`. This produces a binary file called `main` in the root directory, which we can run with `./main`. We can also use the `go run cmd/tutorial_1/main.go` command to compile and run the program in one step.

## Constants, Variables, and Data Types
To declare a variable, we use the `var` keyword, followed by the name of the variable, and then the type of the variable. 
```go
func main() {
    var intNum int
}
```
In addition to the `int` type, we have `int8, int16, int32, int64`. This is used to specify how many bits we use to store the integer. Note that `int` will default to 32 or 64 bits depending on your system architecture. We also have the `uint, uint8, uint16, uint32, uint64` which have the same bit sizes but only stores positive integers.

Next, we have the `float32` and `float64` types for floating point numbers. 

Note that in GO, we cannot perform operations on variables of different types. For example, we cannot add an `int` to a `float32`. To do this, we need to **cast** the variable to the desired type. We do this by using the type name in parentheses before the variable name.
```go
var intNum int = 5
var floatNum float32 = 5.5
var result float32 = float32(intNum) + floatNum
```
Like many programming languages, the division operation `/` on integers will return an integer, which is rounded down.

We can store strings in GO using the `string` type. We can use double quotes or back quotes. Their difference is that double quotes does not allow for multi line, while back quotes do.
```go
var myString1 string = "Hello World!"
var myString2 string = "Hello
World!" // This will throw an error
var myString3 string = `Hello
World!` // This is fine
var myString4 string = "Hello \n World!" //This is also fine
```
Concatenation works by using the `+` operator. We can also use the `+=` operator to append to a string.
```go
var myString5 string = "Hello" + " World!"
myString5 += " I am here!" // myString5 is now "Hello World! I am here!"
```
The `len` function in GO works a little bit differently than other languages. Instead of the number of characters, it returns the number of bytes of a string.
```go
fmt.Println(len("a")) // prints 1
fmt.Println(len("ðŸ‘‹")) // prints 4
```
If we want the number of characters, we have to use the built-in package `unicode/utf8` and use the `RuneCountInString` function.
```go
fmt.Println(utf8.RuneCountInString("ðŸ‘‹")) // prints 1
```
Runes are actually another datatype in GO that represents characters. We can use the `rune` keyword to declare a variable of type rune. We use the single quote to declare a rune.
```go
var myRune rune = 'a'
```
As usual, booleans are declared using the `bool` type. They can either be `true` or `false`.

Variables in GO can be declared without initializing a value.
```go
var myInt int
```
In this case, GO sets a default value for the variable. For integer types, float types, and runes, the default value is 0. For strings, the default value is an empty string, and for booleans, the default value is `false`.

We can also declare a variable but omit the type if we initialize it with a value. GO will infer the type of the variable from the value.
```go
var myVar = "text"
```
We can go a step further and drop the `var` keyword as well by using the `:=` operator. This is called a short declaration.
```go
myVar := "text"
```
We can also declare multiple variables at once.
```go
var myVar1, myVar2, myVar3 int = 1, 2, 3
var myVar4, myVar5, myVar6 = 1, 2, 3
myVar7, myVar8, myVar9 := 1, 2, 3
```
Note that we should always add the type if it is not immediately obvious. For example, if we have a function that returns a value, we should add the type to the variable.
```go
var myVar string = foo()
```
We can also declare constants in GO using the `const` keyword. Constants are immutable, and their value cannot be changed after they are initialized. Constants cannot be declared but not initialized.
```go
const myConst int = 5
const myConst2 string // This will throw an error
```

## Functions and Control Structures
A function in GO is defined as follows:
```go
func myFunction(param1 type1, param2 type2) returnType {
    // code here
}
```
So for example
```go
func intDivision(numerator int, denominator int) int {
    var result int = numerator / denominator
    return result
}
```
A function can return multiple values by using parentheses.
```go
func intDivision(numerator int, denominator int) (int, int) {
    var result int = numerator / denominator
    var remainder int = numerator % denominator
    return result, remainder
}
```
We can use the `Printf` function from the `fmt` package to print to the console with formatting. We use the `%` symbol to indicate where we want to insert a value, and then we list the values at the end of the function call.
```go
fmt.Printf("The result is %d and the remainder is %d", result, remainder)
```
Now what if we pass 0 as a denominator to our division function? There will be a divide by zero error. A design pattern in GO is that if your function can encounter errors, your function should also return a value of type `error` along with the other return values. The `error` type is a built-in type in GO. When we declare an `error` variable, the default value is `nil`.
```go
import (
    "errors",
    "fmt"
)

func intDivision(numerator int, denominator int) (int, int, error) {
    var err error
    if denominator == 0 {
        err = errors.New("Cannot divide by zero")
        return 0, 0, err
    }
    var result int = numerator / denominator
    var remainder int = numerator % denominator
    return result, remainder, err // err is nil here
}

// Then we perform error checking
func main() {
    var result, remainder, err = intDivision(11, 0)
    if err != nil {
        fmt.Printf(err.Error())
    } else if remainder == 0 {
        fmt.Printf("The result is %v", result)
    } else {
        fmt.Printf("The result is %v and the remainder is %v", result, remainder)
    }
}
```
## Arrays, Slices, Maps, and Loops
### Arrays
Arrays are a collection of data with fixed length, same type, indexable, and stored in contiguous memory. The following declares an array of 3 integers.
```go
func main() {
    var intArr [3]int32
    intArr[1] = 123
    fmt.Println(intArr[0]) // gets the first element, 0
    fmt.Println(intArr[1:3]) // gets the second and third element, [123 0]
}
```
Note that the length of the array cannot be changed afterwards. We can print out the memory location of the array using the `&` operator.
```go
fmt.Println(&intArr) // prints the memory location of the first element
fmt.Println(&intArr[1]) // prints the memory location of the second element
```
We could also immediately initialize the array using the following syntax:
```go
var intArr1 [3]int32 = [3]int32{1, 2, 3}
var intArr2 := [3]int32{1, 2, 3}
// We could even omit the length of the array by using the ... syntax
var intArr3 := [...]int32{1, 2, 3}
```
### Slices
Slice are a more flexible version of arrays. Slices wrap arrays to give a more general, powerful, and convenient interface to sequences of data. By omitting the length of the array, we create a slice.
```go
var intSlice []int32 = []int32{1, 2, 3}
intAlice = append(intSlice, 7)
```
A slice has a `length` and a `capacity`. The length is the number of elements in the slice, and the capacity is the number of elements in the underlying array, starting from the first element of the slice. When we append an element to a slice, GO checks if the capacity is enough to store the new element. If it is not, GO creates a new array with double the capacity, copies the old array into the new array, and then appends the new element. 
```go
var intSlice []int32 = []int32{4, 5, 6}
fmt.Printf("The length is %v with capacity %v", len(intSlice), cap(intSlice)) //prints 3, 3
intAlice = append(intSlice, 7)
fmt.Printf("The length is %v with capacity %v", len(intSlice), cap(intSlice)) //prints 4, 6
```
We can append multiple elements to a slice by using the `...` syntax.
```go
var intSlice2 []int32 = []int32{1, 2, 3}
var intSlice3 []int32 = []int32{4, 5, 6}
intSlice2 = append(intSlice2, intSlice3...)
fmt.Println(intSlice2) // prints [1 2 3 4 5 6]
```
Another way to create a slice is to use the `make` function. We specify the length of the slice along with (optionally) the capacity of the slice. If you roughly know how many elements you will be appending to the slice, it is a good idea to specify the capacity to avoid unnecessary reallocation of arrays.
```go
var intSlice3 []int32 = make([]int32, 3, 8) // creates a slice of length 3 and capacity 8
```
### Maps
A map is a set of key-value pairs where you can lookup a value by its key. We can create a map using the `make` function.
```go
var myMap map[string]uint8 = make(map[string]uint8) // creates an empty map of key type string and value type uint8

var myMap2 = map[string]uint8{
    "one": 1,
    "two": 2,
    "three": 3,
}
```
If we try to access a value using a key that does not exist in that map, we get the default value of the value type.
```go
fmt.Println(myMap2["four"]) // prints 0
```
Luckily, GO returns two values when we access a value from a map. The first value is the value of the key, and the second value is a boolean that tells us if the key exists in the map.
```go
var value, exists = myMap2["four"]
if exists {
    fmt.Println(value)
} else {
    fmt.Println("The key does not exist")
}
```
We can also delete a key-value pair from a map using the `delete` function. No return value is given.
```go
delete(myMap2, "one")
```
### Loops
If we want to loop over arrays, slices, or maps, we can use the `range` keyword in a `for` loop.
```go
// loops over the keys of the map
for number := range myMap2 {
    fmt.Printf("%v\n", number)
}
```
Note that when we loop over a map, the ordering of the keys is not guaranteed, so we might get different orders each time we run the program. If we also want to loop over the values, we can do it like this:
```go
// loops over the keys and values of the map
for key, value := range myMap2 {
    fmt.Printf("%v: %v\n", key, value)
}
```
Similarly, we can loop over arrays and slices.
```go
for index, value := range intSlice2 {
    fmt.Printf("Index: %v, Value: %v\n", index, value)
}
```
GO does not have `while` loops, but we can achieve the same thing using the `for` keyword.
```go
var i int = 0
for i < 10 {
    fmt.Println(i)
    i = i + 1
}
// can also omit the condition
for {
    if i >= 10 {
        break
    }
    fmt.Println(i)
    i = i + 1
}
```
Another way to define a loop is using the syntax similar to C.
```go
for i:= 0; i < 10; i++ {
    fmt.Println(i)
}
```
## Strings, Runes, and Bytes
### Strings and Runes
Let's use the word `rÃ©sumÃ©` here since it has a bunch of weird characters (non ASCII). We can index a string using the same notation as an array. We use `%T` to print out a type of a variable in GO.
```go
var myString string = "rÃ©sumÃ©"
var indexed = myString[0]
fmt.Println(indexed) // prints 114
fmt.Printf("%v, %T", indexed, indexed) // prints 114, uint8
```
This is weird, why is it not printing the character `r` like other languages? Let's try to use a for loop to print out its indices and values
```go
for index, value := range myString {
    fmt.Println(index, value)
    // Prints
    // 0 114
    // 1 233
    // 3 115
    // 4 117
    // 5 109
    // 6 233
}
```
We can see that the index skips 2. This is because the string is encoded in UTF-8, which uses a variable number of bytes to encode characters. The `Ã©` character is encoded using two bytes, and has a unicode point number of 233. The underlying array that stores `myString` is an array of bytes
```go
//   r         Ã©                   s         u         m         Ã©
[01110010, 11000011, 10101001, 01110011, 01110101, 01101101, 11000011, 10101001]
```
When we index our string, we are actually indexing the underlying byte array. The key takeaway here is that in GO when you deal with strings, you are dealing with an array of bytes. This is also why when we use the `len` function on a string, we get the number of bytes, not the number of characters. An easier way to deal with strings is to cast it to a slice of runes.
```go
var myString = []rune("rÃ©sumÃ©")
// myString is now [114 233 115 117 109 233]
```
Note that we can declare and initialize a `rune` using the single quote notation. 
```go
var myRune rune = 'a'
```
### String Building
Recall that we can concatenate strings using the `+` operator.
```go
var strSlice = []string{"s", "u", "b", "s", "c", "r", "i", "b", "e"}
var catStr = ""
for i := range strSlice {
    catStr += strSlice[i]
}
fmt.Printf("\n%v", catStr) // prints "subscribe"
```
But strings are immutable, so we cannot modify them once created.
```go
var myString = "subscribe"
myString[0] = "S" // This will throw an error
```
So, when we do string concatenation, we are actually creating a new string every time, this is pretty inefficient. Instead, we can use the `strings` package to build strings.
```go
package main

import (
    "fmt"
    "strings"
)

func main() {
    var strSlice = []string{"s", "u", "b", "s", "c", "r", "i", "b", "e"}
    var strBuilder strings.Builder
    for i := range strSlice {
        strBuilder.WriteString(strSlice[i])
    }
    var catStr = strBuilder.String()
    fmt.Printf("\n%v", catStr) // prints "subscribe"
}
```
What is happening here is that an array is allocated internally and values are appended when calling the `WriteString` method. Only at the end when we call the `String` method is the array converted to a string. This is much more efficient than using the `+` operator.

## Structs and Interfaces
We can think of `structs` as defining our own type. We can create a struct using the `type` and `struct` keyword. `structs` can hold mixed types in the form of fields, which we define my name. When we declare a struct variable, the field's default values are its data type's default values.
```go
package main

type gasEngine struct {
    mpg uint8
    gallons uint8
}

func main() {
    var myEngine gasEngine // mpg is 0, gallons is 0
}
```
If we want to initialize the struct with values, we can do so using the following syntax.
```go
// we can include the field names
var myEngine gasEngine = gasEngine{mpg: 25, gallons: 15}
// or we can omit the field names, following the order of the fields
var myEngine gasEngine = gasEngine{25, 15}
// or we can set the values directly
myEngine.mpg = 20
```
Fields can be anything we want, including other `structs`.
```go
package main

type gasEngine struct {
    mpg uint8
    gallons uint8
    ownerInfo owner
}

type owner struct {
    name string
}

func main() {
    var myEngine gasEngine = gasEngine{mpg: 25, gallons: 15, owner{"Alex"}}
    // myEngine is now { mpg: 25, gallons: 15, ownerInfo: { name: "Alex"}}
    fmt.Println(myEngine.mpg, myEngine.hallons, myEngine.ownerInfo.name) // prints 25, 15, Alex
}
```
If we want, we can even omit the struct name when declaring a field of type another struct.
```go
type gasEngine struct {
    mpg uint8
    gallons uint8
    owner
}
```
This directly injects the `name` field of the `owner` struct into the `gasEngine` struct. 
```go
type gasEngine struct {
    mpg uint8
    gallons uint8
    owner
}

var myEngine gasEngine = gasEngine{25, 15, owner{"Alex"}}
// myEngine is now { mpg: 25, gallons: 15, name: "Alex" }
```
We can also define anonymous structs, which are structs without a name. To create an anonymous struct, we have to define it and initialize it at the same time.
```go
var myEngine = struct {
    mpg uint8
    gallons uint8
}{25, 15}
```
However, this is not reusable, so it is not recommended to use anonymous structs.
### Struct Methods
Struct methods are functions that are directly tied to the struct and have access to the struct instance itself. A method is just like a function, except we have to specify the type of the struct that the method is tied to. 
```go
package main

type gasEngine struct {
    mpg uint8
    gallons uint8
}

// method tied to the gasEngine struct
func (e gasEngine) milesLeft() uint8 {
    return e.gallons * e.mpg
}

func main() {
    var myEngine gasEngine = gasEngine{25, 15}
    fmt.Printf("Total miles left in tank: %v", myEngine.milesLeft())
}
```
We can also pass in a struct as an argument to a function.
```go
package main

type gasEngine struct {
    mpg uint8
    gallons uint8
}

// method tied to the gasEngine struct
func (e gasEngine) milesLeft() uint8 {
    return e.gallons * e.mpg
}

func canMakeIt(e gasEngine, miles uint8) bool {
    return e.milesLeft() >= miles
}

func main() {
    var myEngine gasEngine = gasEngine{25, 15}
    fmt.Printf("Total miles left in tank: %v", myEngine.milesLeft())
}
```
Now suppose that we also have an `electricEngine` type that has different fields from a `gasEngine`. It also has a similar `milesLeft` method
```go
package main

type gasEngine struct {
    mpg uint8
    gallons uint8
}

type electricEngine struct {
    mpkwh uint8
    kwh uint8
}

// method tied to the gasEngine struct
func (e gasEngine) milesLeft() uint8 {
    return e.gallons * e.mpg
}

// method tied to the electricEngine struct
func (e electricEngine) milesLeft() uint8 {
    return e.kwh * e.mpkwh
}

func canMakeIt(e gasEngine, miles uint8) bool {
    return e.milesLeft() >= miles
}

func main() {
    var myEngine gasEngine = gasEngine{25, 15}
    fmt.Printf("Total miles left in tank: %v", myEngine.milesLeft())
}
```
Currently, our `canMakeIt` function only takes in a `gasEngine` as an argument. We can make it more flexible by using an interface. In our `canMakeIt` function, we see that it only really needs the `milesLeft` method that takes no parameters and returns an `uint8`. This is called the **method signature**. We specify it in the interface like this.
```go
package main

type gasEngine struct {
    mpg uint8
    gallons uint8
}

type electricEngine struct {
    mpkwh uint8
    kwh uint8
}

// method tied to the gasEngine struct
func (e gasEngine) milesLeft() uint8 {
    return e.gallons * e.mpg
}

// method tied to the electricEngine struct
func (e electricEngine) milesLeft() uint8 {
    return e.kwh * e.mpkwh
}

// interface here
type engine interface {
    milesLeft() uint8
}


// replace gasEngine with interface engine
func canMakeIt(e engine, miles uint8) bool {
    return e.milesLeft() >= miles
}

func main() {
    var myEngine gasEngine = gasEngine{25, 15}
    fmt.Printf("Can make it: %v", canMakeIt(myEngine, 50))
}
```
The `canMakeIt` function can now take in any parameter with the only requirement that the parameter has a `milesLeft` method with the signature `() uint8`. 

## Pointers
Pointers are a special type that stores memory locations rather than values. We can declare a pointer using the `*` operator. 
```go
package main

func main() {
    var p *int32
    var i int32
}
```
This indicates that the variable `p` will hold the memory address of an `int32` value. The default value for pointers are `nil`. To create a new `int32` value and store its memory address in `p`, we use the `new` function.
```go
var p *int32 = new(int32)
var i int32
```
We can then get the value stored at the memory location pointed to by `p` using the `*` (dereferncing) operator.
```go
var p *int32 = new(int32)
var i int32
fmt.Printf("The value p points to is: %v", *p)
```
To change the value of the memory location pointed to by `p`, we can use the `*` operator to dereference the pointer and then assign a new value to it.
```go
var p *int32 = new(int32)
var i int32
*p = 10
```
We can also have a pointer point to an existing variable.
```go
var p *int32 = new(int32)
var i int32
p = &i

// OR
var p *int32 = &i
```
So if we change the value of `*p`, the value of `i` will also change.
```go
var p *int32 = &i
*p = 10
fmt.Printf("The value of i is: %v", i) // prints 10
```
Slices uses pointers in the underlying array.
```go
var slice = []int32{1, 2, 3}
var sliceCopy = slice
sliceCopy[2] = 4
fmt.Printf("The value of slice is: %v", slice) // prints [1 2 4]
```
We can pass pointers to functions. This is useful when we want to modify the value of a variable in a function.
```go
package main
import "fmt"

func square(thing2 *[5]float64) [5]float64 {
    for i := range thing2 {
        thing2[i] = thing2[i] * thing2[i]
    }
    return thing2
}

func main() {
    var thing1 = [5]float64{1, 2, 3, 4, 5}
    var result [5]float64 = square(thing1)
    fmt.Printf("The result is: %v", result) // prints [1 4 9 16 25]
    fmt.Printf("The original thing1 is: %v", thing1) // prints [1 4 9 16 25]
}
```
Pointers are really useful when we pass in large data structures to functions, as we can avoid copying the entire data structure.
## Goroutines
Goroutines are a way to launch multiple functions and execute them concurrently. Note that concurrency is not equal to parallel execution. Concurrency is mainly for 1 CPU core, the CPU switches between different tasks very quickly, giving the illusion of parallel execution. Parallel execution is when multiple tasks are executed at the same time on different CPU cores. Let's see how we can create a goroutine. First we simulate a database call using the `time` package.
```go
package main
import (
    "fmt"
    "math/rand"
    "time"
)

var dbData = []string{"id1", "id2", "id3", "id4", "id5"}

func dbCall(i int) {
    // Simulate DB call delay
    var delay float32 = rand.Float32() * 2000
    time.sleep(time.Duration(delay) * time.Millisecond)
    fmt.Println("The result from the database is:", dbData[i])
}

func main() {
    for i := 0; i < len(dbData); i++ {
        dbCall(i)
    }
}
```
This will take a long time to execute, as each call to `dbCall` is called sequentially. We can use a goroutine to make the calls concurrently by using the `go` keyword.
```go
package main
import (
    "fmt"
    "math/rand"
    "time"
)

var dbData = []string{"id1", "id2", "id3", "id4", "id5"}

func dbCall(i int) {
    // Simulate DB call delay
    var delay float32 = rand.Float32() * 2000
    time.sleep(time.Duration(delay) * time.Millisecond)
    fmt.Println("The result from the database is:", dbData[i])
}

func main() {
    for i := 0; i < len(dbData); i++ {
        go dbCall(i)
    }
}
```
However, this program spawns these processes, does not wait for them to complete, then ends the program. So we need the program to wait for the goroutines to complete. We can use the `sync` package to do this. We can use the `WaitGroup` type to wait for a group of goroutines to complete. `WaitGroups` are basically counters. Whenever we spawn a new goroutine, we add 1 to the counter, and when a function is done executing, we subtract 1 from the counter. Then we can use the `Wait` method to block the program until the counter is 0.
```go
package main
import (
    "fmt"
    "math/rand"
    "time"
    "sync"
)

// Create a WaitGroup
var wg = sync.WaitGroup{} 
var dbData = []string{"id1", "id2", "id3", "id4", "id5"}

func dbCall(i int) {
    // Simulate DB call delay
    var delay float32 = rand.Float32() * 2000
    time.sleep(time.Duration(delay) * time.Millisecond)
    fmt.Println("The result from the database is:", dbData[i])
    wg.Done() // subtract 1 from the counter
}

func main() {
    for i := 0; i < len(dbData); i++ {
        wg.Add(1) // add 1 to the counter
        go dbCall(i)
    }
    wg.Wait() // wait until all the goroutines are done, i.e. the counter is 0
}
```
Now what if we have multiple goroutines that need to write to the same variable? For example, our `dbCall` function write the results to a slice `results`. This can cause unexpected results because multiple goroutines are trying to write to the same memory location. We use a `mutex` to lock the memory location while a goroutine is writing to it. We can use the `sync` package to create a `Mutex` type. The two main methods are the `Lock` and `Unlock` methods. We use the `Lock` method to lock the memory location, and the `Unlock` method to unlock it. We place them around the part of the code which accesses the shared memory location.
```go
package main
import (
    "fmt"
    "math/rand"
    "time"
    "sync"
)

// Create a WaitGroup
var wg = sync.WaitGroup{} 

// Create a Mutex
var m = sync.Mutex{}
var dbData = []string{"id1", "id2", "id3", "id4", "id5"}
var results = []string{}

func dbCall(i int) {
    // Simulate DB call delay
    var delay float32 = rand.Float32() * 2000
    time.sleep(time.Duration(delay) * time.Millisecond)
    fmt.Println("The result from the database is:", dbData[i])

    // Lock the memory location
    m.Lock()
    results = append(results, dbData[i])
    // After we are done, unlock the memory location
    m.Unlock()
    wg.Done() // subtract 1 from the counter
}

func main() {
    for i := 0; i < len(dbData); i++ {
        wg.Add(1) // add 1 to the counter
        go dbCall(i)
    }
    wg.Wait() // wait until all the goroutines are done, i.e. the counter is 0
}
```
When a goroutine reaches a `Lock` method, it will perform a check to see if a lock has already been set by another goroutine. If it has, it will wait until the lock is released. When the lock is released, the goroutine will set the lock and continue. After the goroutine is done, it will release the lock and allow other goroutines to access the memory location.

Therefore, it really matters where we call the `Lock` methods. If we call it in the wrong location, it can destroy our concurrency.

Now this type of `mutex` might not be what we wanted because it completely locks out other goroutines to accessing our `results` slice. GO provides another `mutex` called the `RWMutex` (Read-write Mutex). The `Lock` and `Unlock` methods work exactly the same, but we also get the `RLock` and `RUnlock` methods (read lock and read unlock).
```go
package main
import (
    "fmt"
    "math/rand"
    "time"
    "sync"
)

// Create a WaitGroup
var wg = sync.WaitGroup{} 

// Create a Mutex
var m = sync.RWMutex{}
var dbData = []string{"id1", "id2", "id3", "id4", "id5"}
var results = []string{}

func dbCall(i int) {
    // Simulate DB call delay
    var delay float32 = rand.Float32() * 2000
    time.sleep(time.Duration(delay) * time.Millisecond)
    save(dbData[i])
    log()
    wg.Done() // subtract 1 from the counter
}

// appends the result to the results slice
func save(result string) {
    // Lock the memory location
    m.Lock()
    results = append(results, result)
    // After we are done, unlock the memory location
    m.Unlock()
}

// reads the results slice and prints out the results
func log() {
    m.RLock()
    fmt.Println("The results so far are:", results)
    m.RUnlock()
}

func main() {
    for i := 0; i < len(dbData); i++ {
        wg.Add(1) // add 1 to the counter
        go dbCall(i)
    }
    wg.Wait() // wait until all the goroutines are done, i.e. the counter is 0
}
```
When a goroutine reaches the line `m.RLock()`, it checks if there is a full lock on the mutex. If there is, it will wait until the lock is released. This way we are not reading when another goroutine is writing. If no full lock exists, the goroutine will aquire a read lock and proceed with the rest of the code. When a goroutine executes the line `m.Lock()`, in order to proceed, all locks must be released (including full locks and read locks). This prevents the slice while other goroutines are writing to/reading from the slice.

## Channels