import { FileTree } from 'nextra/components'

# GO
Notes taken from [this](https://youtu.be/8uiZC0l4Ajw?si=v7CxSfCoaZqs08Yu) video.
## Six Main Points about GO
- It is a statically typed language. This means that the type of a variable is either explicitly declared or inferred by the compiler. The type of a variable cannot change after itâ€™s declared.
- It is a strongly typed language. This means that an operation you can perform on a variable depends on its type. For example, you cannot add a string to an integer.
- GO is compiled, so after compiling, it can output into a standalone executable file, for example `.exe` for Windows. This also results in a faster execution time.
- GO has fast compile times.
- GO has built in concurrency support. This is done with Goroutines.
- Simplicity, its syntax is simple and it has garbage collection for memory management.

## Introduction
There are two concepts in GO, **packages** and **modules**.

A package is just a folder that contains a collection of GO files. 

A module is a collection of packages. So when we initialize a project, we are creating a module.

When we initialize our project/module, we can use the command
```bash
go mod init <module_name>
```
Most commonly the module name is a link to the repository where the code is stored. This creates a `go.mod` file in the root of the project. We see that it contains the following:
```go
module github.com/username/repo_name

go 1.20
```
So it contains the module name and the version of GO that we are using. Let's create a `cmd` directory, and inside it, a `tutorial_1` directory, and inside that, a `main.go` file. 

<FileTree>
    <FileTree.File name="go.mod"/>
    <FileTree.Folder name="cmd">
        <FileTree.Folder name="tutorial_1">
            <FileTree.File name="main.go"/>
        </FileTree.Folder>
    </FileTree.Folder>
</FileTree>
Recall that every GO file is part of a package. We identify the package it belongs to by the first line of the file. For example, in `main.go` we have:
```go
package main
```
This is a special package name that tells the compiler to look for the entrypoint function here. The entrypoint function is `main()`, which is the first thing that gets executed when we run the program. To create a function, we use the `func` keyword, followed by the name of the function, and then the parameters in parentheses.
```go
package main

func main() {
    // code here
}
```
Let's try to print to our console. We need the `fmt` package to do this. We can import it by using the `import` keyword, followed by the package name in double quotes.
```go
package main
import "fmt"

func main() {
    // Println appends a newline character to the end of the string
    fmt.Println("Hello, World!")
}
```
To run the program, we use the command `go build cmd/tutorial_1/main.go`. This produces a binary file called `main` in the root directory, which we can run with `./main`. We can also use the `go run cmd/tutorial_1/main.go` command to compile and run the program in one step.

## Constants, Variables, and Data Types
To declare a variable, we use the `var` keyword, followed by the name of the variable, and then the type of the variable. 
```go
func main() {
    var intNum int
}
```
In addition to the `int` type, we have `int8, int16, int32, int64`. This is used to specify how many bits we use to store the integer. Note that `int` will default to 32 or 64 bits depending on your system architecture. We also have the `uint, uint8, uint16, uint32, uint64` which have the same bit sizes but only stores positive integers.

Next, we have the `float32` and `float64` types for floating point numbers. 

Note that in GO, we cannot perform operations on variables of different types. For example, we cannot add an `int` to a `float32`. To do this, we need to **cast** the variable to the desired type. We do this by using the type name in parentheses before the variable name.
```go
var intNum int = 5
var floatNum float32 = 5.5
var result float32 = float32(intNum) + floatNum
```
Like many programming languages, the division operation `/` on integers will return an integer, which is rounded down.

We can store strings in GO using the `string` type. We can use double quotes or back quotes. Their difference is that double quotes does not allow for multi line, while back quotes do.
```go
var myString1 string = "Hello World!"
var myString2 string = "Hello
World!" // This will throw an error
var myString3 string = `Hello
World!` // This is fine
var myString4 string = "Hello \n World!" //This is also fine
```
Concatenation works by using the `+` operator. We can also use the `+=` operator to append to a string.
```go
var myString5 string = "Hello" + " World!"
myString5 += " I am here!" // myString5 is now "Hello World! I am here!"
```
The `len` function in GO works a little bit differently than other languages. Instead of the number of characters, it returns the number of bytes of a string.
```go
fmt.Println(len("a")) // prints 1
fmt.Println(len("ðŸ‘‹")) // prints 4
```
If we want the number of characters, we have to use the built-in package `unicode/utf8` and use the `RuneCountInString` function.
```go
fmt.Println(utf8.RuneCountInString("ðŸ‘‹")) // prints 1
```
Runes are actually another datatype in GO that represents characters. We can use the `rune` keyword to declare a variable of type rune. We use the single quote to declare a rune.
```go
var myRune rune = 'a'
```
As usual, booleans are declared using the `bool` type. They can either be `true` or `false`.

Variables in GO can be declared without initializing a value.
```go
var myInt int
```
In this case, GO sets a default value for the variable. For integer types, float types, and runes, the default value is 0. For strings, the default value is an empty string, and for booleans, the default value is `false`.

We can also declare a variable but omit the type if we initialize it with a value. GO will infer the type of the variable from the value.
```go
var myVar = "text"
```
We can go a step further and drop the `var` keyword as well by using the `:=` operator. This is called a short declaration.
```go
myVar := "text"
```
We can also declare multiple variables at once.
```go
var myVar1, myVar2, myVar3 int = 1, 2, 3
var myVar4, myVar5, myVar6 = 1, 2, 3
myVar7, myVar8, myVar9 := 1, 2, 3
```
Note that we should always add the type if it is not immediately obvious. For example, if we have a function that returns a value, we should add the type to the variable.
```go
var myVar string = foo()
```
We can also declare constants in GO using the `const` keyword. Constants are immutable, and their value cannot be changed after they are initialized. Constants cannot be declared but not initialized.
```go
const myConst int = 5
const myConst2 string // This will throw an error
```

## Functions and Control Structures
A function in GO is defined as follows:
```go
func myFunction(param1 type1, param2 type2) returnType {
    // code here
}
```
So for example
```go
func intDivision(numerator int, denominator int) int {
    var result int = numerator / denominator
    return result
}
```
A function can return multiple values by using parentheses.
```go
func intDivision(numerator int, denominator int) (int, int) {
    var result int = numerator / denominator
    var remainder int = numerator % denominator
    return result, remainder
}
```
We can use the `Printf` function from the `fmt` package to print to the console with formatting. We use the `%` symbol to indicate where we want to insert a value, and then we list the values at the end of the function call.
```go
fmt.Printf("The result is %d and the remainder is %d", result, remainder)
```
Now what if we pass 0 as a denominator to our division function? There will be a divide by zero error. A design pattern in GO is that if your function can encounter errors, your function should also return a value of type `error` along with the other return values. The `error` type is a built-in type in GO. When we declare an `error` variable, the default value is `nil`.
```go
import (
    "errors",
    "fmt"
)

func intDivision(numerator int, denominator int) (int, int, error) {
    var err error
    if denominator == 0 {
        err = errors.New("Cannot divide by zero")
        return 0, 0, err
    }
    var result int = numerator / denominator
    var remainder int = numerator % denominator
    return result, remainder, err // err is nil here
}

// Then we perform error checking
func main() {
    var result, remainder, err = intDivision(11, 0)
    if err != nil {
        fmt.Printf(err.Error())
    } else if remainder == 0 {
        fmt.Printf("The result is %v", result)
    } else {
        fmt.Printf("The result is %v and the remainder is %v", result, remainder)
    }
}
```
## Arrays, Slices, Maps, and Loops
### Arrays
Arrays are a collection of data with fixed length, same type, indexable, and stored in contiguous memory. The following declares an array of 3 integers.
```go
func main() {
    var intArr [3]int32
    intArr[1] = 123
    fmt.Println(intArr[0]) // gets the first element, 0
    fmt.Println(intArr[1:3]) // gets the second and third element, [123 0]
}
```
Note that the length of the array cannot be changed afterwards. We can print out the memory location of the array using the `&` operator.
```go
fmt.Println(&intArr) // prints the memory location of the first element
fmt.Println(&intArr[1]) // prints the memory location of the second element
```
We could also immediately initialize the array using the following syntax:
```go
var intArr1 [3]int32 = [3]int32{1, 2, 3}
var intArr2 := [3]int32{1, 2, 3}
// We could even omit the length of the array by using the ... syntax
var intArr3 := [...]int32{1, 2, 3}
```
### Slices
Slice are a more flexible version of arrays. Slices wrap arrays to give a more general, powerful, and convenient interface to sequences of data. By omitting the length of the array, we create a slice.
```go
var intSlice []int32 = []int32{1, 2, 3}
intAlice = append(intSlice, 7)
```
A slice has a `length` and a `capacity`. The length is the number of elements in the slice, and the capacity is the number of elements in the underlying array, starting from the first element of the slice. When we append an element to a slice, GO checks if the capacity is enough to store the new element. If it is not, GO creates a new array with double the capacity, copies the old array into the new array, and then appends the new element. 
```go
var intSlice []int32 = []int32{4, 5, 6}
fmt.Printf("The length is %v with capacity %v", len(intSlice), cap(intSlice)) //prints 3, 3
intAlice = append(intSlice, 7)
fmt.Printf("The length is %v with capacity %v", len(intSlice), cap(intSlice)) //prints 4, 6
```
We can append multiple elements to a slice by using the `...` syntax.
```go
var intSlice2 []int32 = []int32{1, 2, 3}
var intSlice3 []int32 = []int32{4, 5, 6}
intSlice2 = append(intSlice2, intSlice3...)
fmt.Println(intSlice2) // prints [1 2 3 4 5 6]
```
Another way to create a slice is to use the `make` function. We specify the length of the slice along with (optionally) the capacity of the slice. If you roughly know how many elements you will be appending to the slice, it is a good idea to specify the capacity to avoid unnecessary reallocation of arrays.
```go
var intSlice3 []int32 = make([]int32, 3, 8) // creates a slice of length 3 and capacity 8
```
### Maps
A map is a set of key-value pairs where you can lookup a value by its key. We can create a map using the `make` function.
```go
var myMap map[string]uint8 = make(map[string]uint8) // creates an empty map of key type string and value type uint8

var myMap2 = map[string]uint8{
    "one": 1,
    "two": 2,
    "three": 3,
}
```
If we try to access a value using a key that does not exist in that map, we get the default value of the value type.
```go
fmt.Println(myMap2["four"]) // prints 0
```
Luckily, GO returns two values when we access a value from a map. The first value is the value of the key, and the second value is a boolean that tells us if the key exists in the map.
```go
var value, exists = myMap2["four"]
if exists {
    fmt.Println(value)
} else {
    fmt.Println("The key does not exist")
}
```
We can also delete a key-value pair from a map using the `delete` function. No return value is given.
```go
delete(myMap2, "one")
```
### Loops
If we want to loop over arrays, slices, or maps, we can use the `range` keyword in a `for` loop.
```go
// loops over the keys of the map
for number := range myMap2 {
    fmt.Printf("%v\n", number)
}
```
Note that when we loop over a map, the ordering of the keys is not guaranteed, so we might get different orders each time we run the program. If we also want to loop over the values, we can do it like this:
```go
// loops over the keys and values of the map
for key, value := range myMap2 {
    fmt.Printf("%v: %v\n", key, value)
}
```
Similarly, we can loop over arrays and slices.
```go
for index, value := range intSlice2 {
    fmt.Printf("Index: %v, Value: %v\n", index, value)
}
```
GO does not have `while` loops, but we can achieve the same thing using the `for` keyword.
```go
var i int = 0
for i < 10 {
    fmt.Println(i)
    i = i + 1
}
// can also omit the condition
for {
    if i >= 10 {
        break
    }
    fmt.Println(i)
    i = i + 1
}
```
Another way to define a loop is using the syntax similar to C.
```go
for i:= 0; i < 10; i++ {
    fmt.Println(i)
}
```
## Strings, Runes, and Bytes
### Strings and Runes
Let's use the word `rÃ©sumÃ©` here since it has a bunch of weird characters (non ASCII). We can index a string using the same notation as an array. We use `%T` to print out a type of a variable in GO.
```go
var myString string = "rÃ©sumÃ©"
var indexed = myString[0]
fmt.Println(indexed) // prints 114
fmt.Printf("%v, %T", indexed, indexed) // prints 114, uint8
```
This is weird, why is it not printing the character `r` like other languages? Let's try to use a for loop to print out its indices and values
```go
for index, value := range myString {
    fmt.Println(index, value)
    // Prints
    // 0 114
    // 1 233
    // 3 115
    // 4 117
    // 5 109
    // 6 233
}
```
We can see that the index skips 2. This is because the string is encoded in UTF-8, which uses a variable number of bytes to encode characters. The `Ã©` character is encoded using two bytes, and has a unicode point number of 233. The underlying array that stores `myString` is an array of bytes
```go
//   r         Ã©                   s         u         m         Ã©
[01110010, 11000011, 10101001, 01110011, 01110101, 01101101, 11000011, 10101001]
```
When we index our string, we are actually indexing the underlying byte array. The key takeaway here is that in GO when you deal with strings, you are dealing with an array of bytes. This is also why when we use the `len` function on a string, we get the number of bytes, not the number of characters. An easier way to deal with strings is to cast it to a slice of runes.
```go
var myString = []rune("rÃ©sumÃ©")
// myString is now [114 233 115 117 109 233]
```
Note that we can declare and initialize a `rune` using the single quote notation. 
```go
var myRune rune = 'a'
```
### String Building
Recall that we can concatenate strings using the `+` operator.
```go
var strSlice = []string{"s", "u", "b", "s", "c", "r", "i", "b", "e"}
var catStr = ""
for i := range strSlice {
    catStr += strSlice[i]
}
fmt.Printf("\n%v", catStr) // prints "subscribe"
```
But strings are immutable, so we cannot modify them once created.
```go
var myString = "subscribe"
myString[0] = "S" // This will throw an error
```
So, when we do string concatenation, we are actually creating a new string every time, this is pretty inefficient. Instead, we can use the `strings` package to build strings.
```go
package main

import (
    "fmt"
    "strings"
)

func main() {
    var strSlice = []string{"s", "u", "b", "s", "c", "r", "i", "b", "e"}
    var strBuilder strings.Builder
    for i := range strSlice {
        strBuilder.WriteString(strSlice[i])
    }
    var catStr = strBuilder.String()
    fmt.Printf("\n%v", catStr) // prints "subscribe"
}
```
What is happening here is that an array is allocated internally and values are appended when calling the `WriteString` method. Only at the end when we call the `String` method is the array converted to a string. This is much more efficient than using the `+` operator.

## Structs and Interfaces
We can think of `structs` as defining our own type. We can create a struct using the `type` and `struct` keyword. `structs` can hold mixed types in the form of fields, which we define my name. When we declare a struct variable, the field's default values are its data type's default values.
```go
package main

type gasEngine struct {
    mpg uint8
    gallons uint8
}

func main() {
    var myEngine gasEngine // mpg is 0, gallons is 0
}
```
If we want to initialize the struct with values, we can do so using the following syntax.
```go
// we can include the field names
var myEngine gasEngine = gasEngine{mpg: 25, gallons: 15}
// or we can omit the field names, following the order of the fields
var myEngine gasEngine = gasEngine{25, 15}
// or we can set the values directly
myEngine.mpg = 20
```
Fields can be anything we want, including other `structs`.
```go
package main

type gasEngine struct {
    mpg uint8
    gallons uint8
    ownerInfo owner
}

type owner struct {
    name string
}

func main() {
    var myEngine gasEngine = gasEngine{mpg: 25, gallons: 15, owner{"Alex"}}
    // myEngine is now { mpg: 25, gallons: 15, ownerInfo: { name: "Alex"}}
    fmt.Println(myEngine.mpg, myEngine.hallons, myEngine.ownerInfo.name) // prints 25, 15, Alex
}
```
If we want, we can even omit the struct name when declaring a field of type another struct.
```go
type gasEngine struct {
    mpg uint8
    gallons uint8
    owner
}
```
This directly injects the `name` field of the `owner` struct into the `gasEngine` struct. 
```go
type gasEngine struct {
    mpg uint8
    gallons uint8
    owner
}

var myEngine gasEngine = gasEngine{25, 15, owner{"Alex"}}
// myEngine is now { mpg: 25, gallons: 15, name: "Alex" }
```
We can also define anonymous structs, which are structs without a name. To create an anonymous struct, we have to define it and initialize it at the same time.
```go
var myEngine = struct {
    mpg uint8
    gallons uint8
}{25, 15}
```
However, this is not reusable, so it is not recommended to use anonymous structs.
### Struct Methods
Struct methods are functions that are directly tied to the struct and have access to the struct instance itself. A method is just like a function, except we have to specify the type of the struct that the method is tied to. 
```go
package main

type gasEngine struct {
    mpg uint8
    gallons uint8
}

// method tied to the gasEngine struct
func (e gasEngine) milesLeft() uint8 {
    return e.gallons * e.mpg
}

func main() {
    var myEngine gasEngine = gasEngine{25, 15}
    fmt.Printf("Total miles left in tank: %v", myEngine.milesLeft())
}
```
We can also pass in a struct as an argument to a function.
```go
package main

type gasEngine struct {
    mpg uint8
    gallons uint8
}

// method tied to the gasEngine struct
func (e gasEngine) milesLeft() uint8 {
    return e.gallons * e.mpg
}

func canMakeIt(e gasEngine, miles uint8) bool {
    return e.milesLeft() >= miles
}

func main() {
    var myEngine gasEngine = gasEngine{25, 15}
    fmt.Printf("Total miles left in tank: %v", myEngine.milesLeft())
}
```
Now suppose that we also have an `electricEngine` type that has different fields from a `gasEngine`. It also has a similar `milesLeft` method
```go
package main

type gasEngine struct {
    mpg uint8
    gallons uint8
}

type electricEngine struct {
    mpkwh uint8
    kwh uint8
}

// method tied to the gasEngine struct
func (e gasEngine) milesLeft() uint8 {
    return e.gallons * e.mpg
}

// method tied to the electricEngine struct
func (e electricEngine) milesLeft() uint8 {
    return e.kwh * e.mpkwh
}

func canMakeIt(e gasEngine, miles uint8) bool {
    return e.milesLeft() >= miles
}

func main() {
    var myEngine gasEngine = gasEngine{25, 15}
    fmt.Printf("Total miles left in tank: %v", myEngine.milesLeft())
}
```
Currently, our `canMakeIt` function only takes in a `gasEngine` as an argument. We can make it more flexible by using an interface. In our `canMakeIt` function, we see that it only really needs the `milesLeft` method that takes no parameters and returns an `uint8`. This is called the **method signature**. We specify it in the interface like this.
```go
package main

type gasEngine struct {
    mpg uint8
    gallons uint8
}

type electricEngine struct {
    mpkwh uint8
    kwh uint8
}

// method tied to the gasEngine struct
func (e gasEngine) milesLeft() uint8 {
    return e.gallons * e.mpg
}

// method tied to the electricEngine struct
func (e electricEngine) milesLeft() uint8 {
    return e.kwh * e.mpkwh
}

// interface here
type engine interface {
    milesLeft() uint8
}


// replace gasEngine with interface engine
func canMakeIt(e engine, miles uint8) bool {
    return e.milesLeft() >= miles
}

func main() {
    var myEngine gasEngine = gasEngine{25, 15}
    fmt.Printf("Can make it: %v", canMakeIt(myEngine, 50))
}
```
The `canMakeIt` function can now take in any parameter with the only requirement that the parameter has a `milesLeft` method with the signature `() uint8`. 

## Pointers
Pointers are a special type that stores memory locations rather than values. We can declare a pointer using the `*` operator. 
```go
package main

func main() {
    var p *int32
    var i int32
}
```
This indicates that the variable `p` will hold the memory address of an `int32` value. The default value for pointers are `nil`. To create a new `int32` value and store its memory address in `p`, we use the `new` function.
```go
var p *int32 = new(int32)
var i int32
```
We can then get the value stored at the memory location pointed to by `p` using the `*` (dereferncing) operator.
```go
var p *int32 = new(int32)
var i int32
fmt.Printf("The value p points to is: %v", *p)
```
To change the value of the memory location pointed to by `p`, we can use the `*` operator to dereference the pointer and then assign a new value to it.
```go
var p *int32 = new(int32)
var i int32
*p = 10
```
We can also have a pointer point to an existing variable.
```go
var p *int32 = new(int32)
var i int32
p = &i

// OR
var p *int32 = &i
```
So if we change the value of `*p`, the value of `i` will also change.
```go
var p *int32 = &i
*p = 10
fmt.Printf("The value of i is: %v", i) // prints 10
```
Slices uses pointers in the underlying array.
```go
var slice = []int32{1, 2, 3}
var sliceCopy = slice
sliceCopy[2] = 4
fmt.Printf("The value of slice is: %v", slice) // prints [1 2 4]
```
We can pass pointers to functions. This is useful when we want to modify the value of a variable in a function.
```go
package main
import "fmt"

func square(thing2 *[5]float64) [5]float64 {
    for i := range thing2 {
        thing2[i] = thing2[i] * thing2[i]
    }
    return thing2
}

func main() {
    var thing1 = [5]float64{1, 2, 3, 4, 5}
    var result [5]float64 = square(thing1)
    fmt.Printf("The result is: %v", result) // prints [1 4 9 16 25]
    fmt.Printf("The original thing1 is: %v", thing1) // prints [1 4 9 16 25]
}
```
Pointers are really useful when we pass in large data structures to functions, as we can avoid copying the entire data structure.
## Goroutines
Goroutines are a way to launch multiple functions and execute them concurrently. Note that concurrency is not equal to parallel execution. Concurrency is mainly for 1 CPU core, the CPU switches between different tasks very quickly, giving the illusion of parallel execution. Parallel execution is when multiple tasks are executed at the same time on different CPU cores. Let's see how we can create a goroutine. First we simulate a database call using the `time` package.
```go
package main
import (
    "fmt"
    "math/rand"
    "time"
)

var dbData = []string{"id1", "id2", "id3", "id4", "id5"}

func dbCall(i int) {
    // Simulate DB call delay
    var delay float32 = rand.Float32() * 2000
    time.sleep(time.Duration(delay) * time.Millisecond)
    fmt.Println("The result from the database is:", dbData[i])
}

func main() {
    for i := 0; i < len(dbData); i++ {
        dbCall(i)
    }
}
```
This will take a long time to execute, as each call to `dbCall` is called sequentially. We can use a goroutine to make the calls concurrently by using the `go` keyword.
```go
package main
import (
    "fmt"
    "math/rand"
    "time"
)

var dbData = []string{"id1", "id2", "id3", "id4", "id5"}

func dbCall(i int) {
    // Simulate DB call delay
    var delay float32 = rand.Float32() * 2000
    time.sleep(time.Duration(delay) * time.Millisecond)
    fmt.Println("The result from the database is:", dbData[i])
}

func main() {
    for i := 0; i < len(dbData); i++ {
        go dbCall(i)
    }
}
```
However, this program spawns these processes, does not wait for them to complete, then ends the program. So we need the program to wait for the goroutines to complete. We can use the `sync` package to do this. We can use the `WaitGroup` type to wait for a group of goroutines to complete. `WaitGroups` are basically counters. Whenever we spawn a new goroutine, we add 1 to the counter, and when a function is done executing, we subtract 1 from the counter. Then we can use the `Wait` method to block the program until the counter is 0.
```go
package main
import (
    "fmt"
    "math/rand"
    "time"
    "sync"
)

// Create a WaitGroup
var wg = sync.WaitGroup{} 
var dbData = []string{"id1", "id2", "id3", "id4", "id5"}

func dbCall(i int) {
    // Simulate DB call delay
    var delay float32 = rand.Float32() * 2000
    time.sleep(time.Duration(delay) * time.Millisecond)
    fmt.Println("The result from the database is:", dbData[i])
    wg.Done() // subtract 1 from the counter
}

func main() {
    for i := 0; i < len(dbData); i++ {
        wg.Add(1) // add 1 to the counter
        go dbCall(i)
    }
    wg.Wait() // wait until all the goroutines are done, i.e. the counter is 0
}
```
Now what if we have multiple goroutines that need to write to the same variable? For example, our `dbCall` function write the results to a slice `results`. This can cause unexpected results because multiple goroutines are trying to write to the same memory location. We use a `mutex` to lock the memory location while a goroutine is writing to it. We can use the `sync` package to create a `Mutex` type. The two main methods are the `Lock` and `Unlock` methods. We use the `Lock` method to lock the memory location, and the `Unlock` method to unlock it. We place them around the part of the code which accesses the shared memory location.
```go
package main
import (
    "fmt"
    "math/rand"
    "time"
    "sync"
)

// Create a WaitGroup
var wg = sync.WaitGroup{} 

// Create a Mutex
var m = sync.Mutex{}
var dbData = []string{"id1", "id2", "id3", "id4", "id5"}
var results = []string{}

func dbCall(i int) {
    // Simulate DB call delay
    var delay float32 = rand.Float32() * 2000
    time.sleep(time.Duration(delay) * time.Millisecond)
    fmt.Println("The result from the database is:", dbData[i])

    // Lock the memory location
    m.Lock()
    results = append(results, dbData[i])
    // After we are done, unlock the memory location
    m.Unlock()
    wg.Done() // subtract 1 from the counter
}

func main() {
    for i := 0; i < len(dbData); i++ {
        wg.Add(1) // add 1 to the counter
        go dbCall(i)
    }
    wg.Wait() // wait until all the goroutines are done, i.e. the counter is 0
}
```
When a goroutine reaches a `Lock` method, it will perform a check to see if a lock has already been set by another goroutine. If it has, it will wait until the lock is released. When the lock is released, the goroutine will set the lock and continue. After the goroutine is done, it will release the lock and allow other goroutines to access the memory location.

Therefore, it really matters where we call the `Lock` methods. If we call it in the wrong location, it can destroy our concurrency.

Now this type of `mutex` might not be what we wanted because it completely locks out other goroutines to accessing our `results` slice. GO provides another `mutex` called the `RWMutex` (Read-write Mutex). The `Lock` and `Unlock` methods work exactly the same, but we also get the `RLock` and `RUnlock` methods (read lock and read unlock).
```go
package main
import (
    "fmt"
    "math/rand"
    "time"
    "sync"
)

// Create a WaitGroup
var wg = sync.WaitGroup{} 

// Create a Mutex
var m = sync.RWMutex{}
var dbData = []string{"id1", "id2", "id3", "id4", "id5"}
var results = []string{}

func dbCall(i int) {
    // Simulate DB call delay
    var delay float32 = rand.Float32() * 2000
    time.sleep(time.Duration(delay) * time.Millisecond)
    save(dbData[i])
    log()
    wg.Done() // subtract 1 from the counter
}

// appends the result to the results slice
func save(result string) {
    // Lock the memory location
    m.Lock()
    results = append(results, result)
    // After we are done, unlock the memory location
    m.Unlock()
}

// reads the results slice and prints out the results
func log() {
    m.RLock()
    fmt.Println("The results so far are:", results)
    m.RUnlock()
}

func main() {
    for i := 0; i < len(dbData); i++ {
        wg.Add(1) // add 1 to the counter
        go dbCall(i)
    }
    wg.Wait() // wait until all the goroutines are done, i.e. the counter is 0
}
```
When a goroutine reaches the line `m.RLock()`, it checks if there is a full lock on the mutex. If there is, it will wait until the lock is released. This way we are not reading when another goroutine is writing. If no full lock exists, the goroutine will aquire a read lock and proceed with the rest of the code. When a goroutine executes the line `m.Lock()`, in order to proceed, all locks must be released (including full locks and read locks). This prevents the slice while other goroutines are writing to/reading from the slice.

## Channels
At a high level, channels are a way to enable goroutines to pass around information. Channels
1. Hold data, for example an integer, a slice etc.
2. are thread safe, i.e. we avoid data races when we read and write from memory.
3. listen for when data is added or removed from a channel, and can block code execution until one of these events happen.

To make a channel, we use the `make` function, followed by the `chan` keyword and the type of data we want to pass around.
```go
var c = make(chan int)
```
This channel can only hold a single `int` value. They also have a special syntax for assigning values, `<-`.
```go
c <- 5 // sends the value 5 to the channel
```
We can think of channels as like a pipe. We can pop the data out of the channel using the `<-` operator.
```go
var i = <- c // pops the value out of the channel, now channel is empty
```
But actually the following code does not work
```go
var c = make(chan int)
c <- 5 // sends the value 5 to the channel
var i = <- c // pops the value out of the channel, now channel is empty
```
This is because when we write to a channel, the code will block until something else reads from it, so we'll be waiting at the line `c <- 5` forever. A proper way to use this is with a goroutine.
```go
func main() {
    var c = make(chan int)
    go process(c) // 1. start our go routine
    fmt.Println(<-c) // 2. program moves to this line, where it wait for a value to be sent to the channel
    // 4. main function notices a value has been set, print value gets called and the value gets printed
}

func process(c chan int) {
    c <- 123 // 3. send the value 123 to the channel
}
```
What if we have a `for` loop like this?
```go
func main() {
    var c = make(chan int)
    go process(c) // 1. start our go routine
    for i := range c { // 2. wait at the top of the for loop for something to be added to the channel
        fmt.Println(i) // 4. 0 is printed
        // 6. 1 is printed, etc.
    }
}

func process(c chan int) {
    for i := 0; i < 5; i++ {
        c <- i // 3. add 0 to the channel
        // 5. add 1 to the channel
    }
}
```
Notice that when we run this, we will encounter the deadlock error, because after we print all of our values from 0 to 4, the main function will go back to wait at the top of the loop. Instead, what we have to do is to close the channel before exiting a process.
```go
func process(c chan int) {
    for i := 0; i < 5; i++ {
        c <- i 
    }
    close(c) // close the channel
}
```
This notifies any other processes using this channel that we are done, and the main function will break out of the loop and exit. We can also use the `defer` keyword, that will execute a function when the current function is done executing.
```go
func process(c chan int) {
    defer close(c) // close the channel when the function is done executing
    for i := 0; i < 5; i++ {
        c <- i 
    }
}
```
A channel that only stores 1 value is called an **unbuffered channel**. We can also create a channel that stores multiple values, called a **buffered channel**.
```go
func main() {
    var c = make(chan int, 5) // creates buffered channel
    go process(c) 
    for i := range c { 
        fmt.Println(i) 
        time.Sleep(time.Second * 1) // does some work
    }
}

func process(c chan int) {
    defer close(c) // close the channel when the function is done executing
    for i := 0; i < 5; i++ {
        c <- i 
    }
    fmt.Println("Exiting process")
}
```
This will print out `Exiting process`, then the main function will print out the values from 0 to 4. That is, the process function will add values to the channel without having to wait for the main function to make room for them by popping out a value from the channel. Let's see an example of a more useful application of channels.

We have a program that mocks checking for sales on chicken fingers at Walmart, Costco, and Wholefoods. If it finds a sale, it will send a message, notifying the user of the sale.
```go
package main

import (
    "fmt"
    "math/rand"
    "time"
)

var MAX_CHICKEN_PRICE float32 = 5

func main() {
    var chickenChannel = make(chan string)
    var websites = []string{"walmart.com", "costco.com", "wholefoods.com"}
    for i := range websites {
        go checkChickenPrices(websites[i], chickenChannel) // spawns 3 goroutines to check for sales
    }
    sendMessage(chickenChannel)
}

func checkChickenPrices(website string, chickenChannel chan string) {
    for {
        time.Sleep(time.Second * 1)
        var chickenPrice = rand.Float32() * 20 // simulate chicken price
        if chickenPrice <= MAX_CHICKEN_PRICE {
            chickenChannel <- website
            break
        }
    }
}

func sendMessage(chickenChannel chan string) {
    fmt.Printf("\nFound a deal on chicken at %s", <-chickenChannel)
}
```
The first goroutine to find a deal on chicken will send a message to the `chickenChannel`, and the `sendMessage` function will print out the message, then the program will exit.

Suppose we want to check for tofu as well.
```go
package main

import (
    "fmt"
    "math/rand"
    "time"
)

var MAX_CHICKEN_PRICE float32 = 5
var MAX_TOFU_PRICE float32 = 3

func main() {
    var chickenChannel = make(chan string)
    var tofuChannel = make(chan string)
    var websites = []string{"walmart.com", "costco.com", "wholefoods.com"}
    for i := range websites {
        go checkChickenPrices(websites[i], chickenChannel) 
        go checkTofuPrices(websites[i], tofuChannel) 
    }
    sendMessage(chickenChannel)
}

func checkChickenPrices(website string, tofuChannel chan string) {
    for {
        time.Sleep(time.Second * 1)
        var tofuPrice = rand.Float32() * 20 
        if tofuPrice <= MAX_TOFU_PRICE {
            tofuChannel <- website
            break
        }
    }
}

func checkChickenPrices(website string, chickenChannel chan string) {
    for {
        time.Sleep(time.Second * 1)
        var chickenPrice = rand.Float32() * 20 // simulate chicken price
        if chickenPrice <= MAX_CHICKEN_PRICE {
            chickenChannel <- website
            break
        }
    }
}

func sendMessage(chickenChannel chan string, tofuChannel chan string) {
    // If we get a sale on tofu, we send an email instead of a message
    // we can use a select statement
    select {
        case website := <-chickenChannel:
            fmt.Printf("\nText Sent: Found deal on chicken at %v", website)
        case website := <-tofuChannel:
            fmt.Printf("\nEmail Sent: Found deal on tofu at %v", website)
    }
}
```
The `select` statement is like an `if` statement for channels. What happens is if we receive a message from the `chickenChannel`, we set the variable website to the value of in the channel, and we sent a text. Otherwise, if we receive a message from the `tofuChannel`, we set the variable website to the value of in the channel, and we send an email. So the `select` statement will listen for a result, and once it gets one, it will execute one of the statements, and exit.

## Generics
Suppose we have a function that sums up the values of an integer slice. But then we also want a similar function for a float32 slice. We can use generics to handle this.
```go
package main

import "fmt"

func main() {
    var intSlice = []int{1, 2, 3}
    fmt.Println(sumSlice[int](intSlice))

    var float32Slice = []float32{1.1, 2.2, 3.3}
    fmt.Println(sumSlice[float32](float32Slice))
}

func sumSlice[T int | float32 | float64](slice []T) T {
    var sum T
    for _, v := range slice {
        sum += v
    }
    return sum
}
```
So the `sumSlice` function can take in a slice that is an `int`, `float32`, or `float64`. So when we pass in an integer slice by `sumSlice[int](intSlice)`, we can replace all instances of `T` with `int` in the function. We can also use the `any` type to specify that the type can be anything, however it does not work everywhere.
```go
// This does not work because not all types are compatible with the + operator
func sumSlice[T any](slice []T) T {
    var sum T
    for _, v := range slice {
        sum += v
    }
    return sum
}
```
Instead, we can use the `any` type here
```go
func isEmpty[T any](slice []T) bool {
    return len(slice) == 0
}
```
Generics also works in structs
```go
package main

import "fmt"

type gasEngine struct {
    gallons float32
    mpg float32
}

type electricEngine struct {
    kwh float32
    mpkwh float32
}

type car [T gasEngine | electricEngine] struct {
    carMake string
    carModel string
    engine T
}

func main() {
    var gasCar = car[gasEngine]{
        carMake: "Honda",
        carModel: "Civic",
        engine: gasEngine{
            gallons: 12.4,
            mpg: 40,
        }
    }

    var electricCar = car[electricEngine]{
        carMake: "Tesla",
        carModel: "Model 3",
        engine: electricEngine{
            kwh: 57.5,
            mpkwh: 4.17,
        }
    }
}
```

## Example API Project
First let's initialize our project
```bash
go mod init github.com/pl3lee/example-go-project
```
Many GO projects adhere to a standard layout. [Here](https://github.com/golang-standards/project-layout) is a GitHub repository of standard layouts for GO projects. Lets make an `api` folder, here we are going to have our specs such as parameters and response types for our endpoints. This is also where we put our `yaml` spec file.

Then we create a `cmd/api` folder which will contain our `main.go` folder. We also have an `internal` folder that contains most of our code for our API. Let's also create an `api.go` file in our `api` folder.
<FileTree>
    <FileTree.Folder name="api">
        <FileTree.File name="api.go" />
    </FileTree.Folder>
    <FileTree.Folder name="cmd">
        <FileTree.Folder name="api">
            <FileTree.File name="main.go" />
        </FileTree.Folder>
    </FileTree.Folder>
    <FileTree.Folder name="internal" />
</FileTree>

```go
// api/api.go
package api

import (
    "encoding/json"
    "net/http"
)

// Coin Balance Params: represents the parameters that our API endpoint will take. In this case we just require the username
type CoinBalanceParams struct {
    Username string
}

// Coin Balance Response: outlines a successful response from the server containing a status code and the account balance
type CoinBalanceResponse struct {
    Code int
    Balance int64
}

// Error Response: outlines a failed response from the server containing a status code and an error message
type ErrorResponse struct {
    Code int
    Message string
}

// This function is going to return an error response to the person who called the endpoint. We write the function here because we want to reuse this function in multiple places when we want to return an error
func writeError(w http.ResponseWriter, message string, code int) {
    resp := Error{
        Code: code,
        Message: message,
    }

    // set content type, i.e. we want to return a json
    w.Header().Set("Content-Type", "application/json")
    // write the error code
    w.WriteHeader(code)

    // json.NewEncoder(w) creates a new json encoder object that writes to the response writer
    // .Encode(resp) writes the resp object (which is an error) into JSON
    json.NewEncoder(w).Encode(resp)
}

// Now we create some wrappers for our error handling, because we want different types of error
var (
    // We use this when we want a specific error in our response, this guides the caller to fix his request
    RequestErrorHandler = func(w http.ResponseWriter, err error) {
        writeError(w, err.Error(), http.StatusBadRequest)
    }
    // We use this when we want to return a generic error message. For example, when we have a bug in our code, we don't want to return the error message to the caller, so we return a generic error message
    InternalErrorHandler = func(w http.ResponseWriter) {
        writeError(w, "An Unexpected Error Occured.", http.StatusInternalServerError)
    }
)
```
Now let's define our main package in `cmd/api/main.go`. When we import an external package, we can install it using `go mod tidy`. After running the command, we will see the packages listed in the `go.mod` file.
```go
// cmd/api/main.go
package main

import (
    "fmt"
    "net/http"

    // the chi package is a flexible package for web development
    "github.com/go-chi/chi"
    // imports a package from our own module in the internal/handlers folder
    "github.com/pl3lee/example-go-project/internal/handlers"
    // used to log errors for debugging, aliased as just log
    log "github.com/sirupsen/logrus"
)

func main() {
    // when we print something out, we get the file and the line number
    log.SetReportCaller(true)
    // create a new chi Mux variable, which is just a struct that we use to setup our API
    var r *chi.Mux = chi.NewRouter()
    // pass in the chi Mux variable to the Handler function
    handlers.Handler(r)

    fmt.Println("Starting GO API service...")

    // takes in the base location of the server and a handler which our mux type satisfies
    err := http.ListenAndServe("localhost:8000", r)
    if err != nil {
        log.Error(err)
    }
}
```
Now let's create our `Handler` function which sets up our router in the `internal/handlers/api.go` file.
```go
// internal/handlers/api.go
package handlers

import (
    "github.com/go-chi/chi"
    // middleware is a function that gets called before the primary function gets called that handles the endpoint
    chimiddle "github.com/go-chi/chi/middleware"
    "github.com/pl3lee/example-go-project/internal/middleware"
)

// our function name starts with Uppercase, this tells the compiler that our function can be imported into other packages. Functions that start with lowercase are private to the package
func Handler(r *chi.Mux) {
    // global middleware
    // what this does, it ignores the trailing slashes, for example, if we do http://localhost:8000/account/coins/ it will be the same as http://localhost:8000/account/coins
    r.Use(chimiddle.StripSlashes)

    // setup our route
    r.Route("/account", func(router chi.Router) {
        // Middleware for /account route, checks if user is authorized to access this account. This will be defined later in our middleware package
        router.Use(middleware.Authorization)

        // the GET method to /account/coins is handled by the GetCoinBalance function, will be defined later
        router.Get("/coins", GetCoinBalance)
    })
}
```
Now let's define our `Authorization` middleware in the `internal/middleware/authorization.go` file.
```go
// internal/middleware/authorization.go
package middleware

import (
    "errors"
    "net/http"

    "github.com/pl3lee/example-go-project/api"
    "github.com/pl3lee/example-go-project/internal/tools"
    log "github.com/sirupsen/logrus"
)

var UnAuthorizedError = errors.New("Invalid username or token.")

// since we are using our Authorization function as middleware, this needs to follow a certain signature. It needs to take in a http.Handler and return a http.Handler
func Authorization(next http.Handler) http.Handler {
    // we return a http.HandlerFunc, which itself takes a function with the signature http.ResponseWriter and *http.Request
    // the http.ResponseWriter is what we use to construct a response to the caller, for example we can write a status code, or write a response body
    // the *http.Request is the request that the client made to the server which contains information such as the URL, the headers, and the body
    return http.HandlerFunc(func(w http.ResponseWriter, r *http.Request) {
        var username string = r.URL.Query().Get("username")
        var token = r.Header.Get("Authorization")
        var err error

        if username == "" || token == "" {
            log.Error(UnAuthorizedError)
            // Use the error handler we defined in the api package to return an error response
            api.RequestErrorHandler(w, UnAuthorizedError)
            return
        }

        // will be defined later
        var database *tools.DatabaseInterface
        database, err = tools.NewDatabase()
        if err != nil {
            api.InternalErrorHandler(w)
            return
        }

        // gets login details from the database, and checks if the token is valid
        var loginDetails *tools.LoginDetails
        loginDetails = (*database).GetUserLoginDetails(username)

        if (loginDetails == nil || (token != (*loginDetails).AuthToken)) {
            log.Error(UnAuthorizedError)
            api.RequestErrorHandler(w, UnAuthorizedError)
            return
        }

        // This calls the next middleware in line or the handler function for the endpoint if there is no middlware left
        next.ServeHTTP(w, r)
    })
}
```
Now we create our database functions in the `internal/tools/database.go` file.
```go
// internal/tools/database.go
package tools

import (
    log "github.com/sirupsen/logrus"
)

type LoginDetails struct {
    AuthToken string
    Username string
}

type CoinDetails struct {
    Coins int64
    Username string
}

// this defines a few methods that are required for our API
// we are using an interface here because this makes swapping our databases really easy, as long as we define the three methods below
type DatabaseInterface interface {
    GetUserLoginDetails(username string) *LoginDetails
    GetUserCoins(username string) *CoinDetails
    SetupDatabase() error
}

func NewDatabase() (*DatabaseInterface, error) {
    // this is a struct that we are going to create that is going to implement our interface
    var database DatabaseInterface = &mockDB{}

    var err error = database.SetupDatabase()
    if err != nil {
        log.Error(err)
        return nil, err
    }

    return &database, nil
}
```
Now let's create a mock database in the `internal/tools/mockdb.go` file.
```go
// internal/tools/mockdb.go

package tools

import (
    "time"
)

type mockDB struct {}

var mockLoginDetails = map[string]LoginDetails {
    "alex": {
        AuthToken: "123ABC",
        Username: "alex",
    },
    "jason": {
        AuthToken: "456DEF",
        Username: "jason",
    },
    "marie": {
        AuthToken: "789GHI",
        Username: "marie",
    },
}

var mockCoinDetails = map[string]CoinDetails {
    "alex": {
        Coins: 100,
        Username: "alex",
    },
    "jason": {
        Coins: 200,
        Username: "jason",
    },
    "marie": {
        Coins: 300,
        Username: "marie",
    },
}

// we need to create these functions to conform to our DatabaseInterface
func (d *mockDB) GetUserLoginDetails(username string) *LoginDetails {
    // Simulate DB call
    time.Sleep(time.Second * 1)

    var clientData = LoginDetails{}
    clientData, ok := mockLoginDetails[username]
    if !ok {
        return nil
    }
    return &clientData
}

func (d *mockDB) GetUserCoins(username string) *CoinDetails {
    // Simulate DB call
    time.Sleep(time.Second * 1)

    var clientData = CoinDetails{}
    clientData, ok := mockCoinDetails[username]
    if !ok {
        return nil
    }
    return &clientData
}

func (d *mockDB) SetupDatabase() error {
    return nil
}
```
Now we need to define our `GetCoinBalance` function in the `internal/handlers/get_coin_balance.go` file.
```go
// internal/handlers/get_coin_balance.go
package handlers

import (
    "encoding/json"
    "net/http"

    "github.com/pl3lee/example-go-project/api"
    "github.com/pl3lee/example-go-project/internal/tools"
    log "github.com/sirupsen/logrus"
    "github.com/gorilla/schema"
)

// here we are assuming that the authorization middleware has already been called, so we just need to grab the username from the request
func GetCoinBalance(w http.ResponseWriter, r *http.Request) {
    var params = api.CoinBalanceParams{}
    var decoder *schema.Docoder = schema.NewDecoder()
    var err error

    // this line grabs the query parameters in the URL and set them to the values in the struct CoinBalanceParams. In this case it will just grab the username from the URL and put it in the username field in the struct
    err = decoder.Decode(&params, r.URL.Query())

    if err != nil {
        log.Error(err)
        api.InternalErrorHandler(w)
        return
    }

    // instantiate a database interface
    var database *tools.DatabaseInterface
    database, err = tools.NewDatabase()
    if err != nil {
        api.InternalErrorHandler(w)
        return
    }

    // call the GetUserCoins method
    var tokenDetails *tools.CoinDetails
    tokenDetails = (*database).GetUserCoins(params.Username)
    if tokenDetails == nil {
        log.Error(err)
        api.InternalErrorHandler(w)
        return
    }

    // set the value to our response struct
    var response = api.CoinBalanceResponse {
        Balance: (*tokenDetails).Coins,
        Code: http.StatusOK,
    }

    // write it to the response writer
    w.Header().Set("Content-Type", "application/json")
    err = json.NewEncoder(w).Encode(response)
    if err != nil {
        log.Error(err)
        api.InternalErrorHandler(w)
        return
    }
}
```
Done!

