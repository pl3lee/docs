import { FileTree } from 'nextra/components'

# GO
Notes taken from [this](https://youtu.be/8uiZC0l4Ajw?si=v7CxSfCoaZqs08Yu) video.
## Six Main Points about GO
- It is a statically typed language. This means that the type of a variable is either explicitly declared or inferred by the compiler. The type of a variable cannot change after itâ€™s declared.
- It is a strongly typed language. This means that an operation you can perform on a variable depends on its type. For example, you cannot add a string to an integer.
- GO is compiled, so after compiling, it can output into a standalone executable file, for example `.exe` for Windows. This also results in a faster execution time.
- GO has fast compile times.
- GO has built in concurrency support. This is done with Goroutines.
- Simplicity, its syntax is simple and it has garbage collection for memory management.

## Introduction
There are two concepts in GO, **packages** and **modules**.

A package is just a folder that contains a collection of GO files. 

A module is a collection of packages. So when we initialize a project, we are creating a module.

When we initialize our project/module, we can use the command
```bash
go mod init <module_name>
```
Most commonly the module name is a link to the repository where the code is stored. This creates a `go.mod` file in the root of the project. We see that it contains the following:
```go
module github.com/username/repo_name

go 1.20
```
So it contains the module name and the version of GO that we are using. Let's create a `cmd` directory, and inside it, a `tutorial_1` directory, and inside that, a `main.go` file. 

<FileTree>
    <FileTree.File name="go.mod"/>
    <FileTree.Folder name="cmd">
        <FileTree.Folder name="tutorial_1">
            <FileTree.File name="main.go"/>
        </FileTree.Folder>
    </FileTree.Folder>
</FileTree>
Recall that every GO file is part of a package. We identify the package it belongs to by the first line of the file. For example, in `main.go` we have:
```go
package main
```
This is a special package name that tells the compiler to look for the entrypoint function here. The entrypoint function is `main()`, which is the first thing that gets executed when we run the program. To create a function, we use the `func` keyword, followed by the name of the function, and then the parameters in parentheses.
```go
package main

func main() {
    // code here
}
```
Let's try to print to our console. We need the `fmt` package to do this. We can import it by using the `import` keyword, followed by the package name in double quotes.
```go
package main
import "fmt"

func main() {
    // Println appends a newline character to the end of the string
    fmt.Println("Hello, World!")
}
```
To run the program, we use the command `go build cmd/tutorial_1/main.go`. This produces a binary file called `main` in the root directory, which we can run with `./main`. We can also use the `go run cmd/tutorial_1/main.go` command to compile and run the program in one step.

## Constants, Variables, and Data Types
To declare a variable, we use the `var` keyword, followed by the name of the variable, and then the type of the variable. 
```go
func main() {
    var intNum int
}
```
In addition to the `int` type, we have `int8, int16, int32, int64`. This is used to specify how many bits we use to store the integer. Note that `int` will default to 32 or 64 bits depending on your system architecture. We also have the `uint, uint8, uint16, uint32, uint64` which have the same bit sizes but only stores positive integers.

Next, we have the `float32` and `float64` types for floating point numbers. 

Note that in GO, we cannot perform operations on variables of different types. For example, we cannot add an `int` to a `float32`. To do this, we need to **cast** the variable to the desired type. We do this by using the type name in parentheses before the variable name.
```go
var intNum int = 5
var floatNum float32 = 5.5
var result float32 = float32(intNum) + floatNum
```
Like many programming languages, the division operation `/` on integers will return an integer, which is rounded down.

We can store strings in GO using the `string` type. We can use double quotes or back quotes. Their difference is that double quotes does not allow for multi line, while back quotes do.
```go
var myString1 string = "Hello World!"
var myString2 string = "Hello
World!" // This will throw an error
var myString3 string = `Hello
World!` // This is fine
var myString4 string = "Hello \n World!" //This is also fine
```
Concatenation works by using the `+` operator. We can also use the `+=` operator to append to a string.
```go
var myString5 string = "Hello" + " World!"
myString5 += " I am here!" // myString5 is now "Hello World! I am here!"
```
The `len` function in GO works a little bit differently than other languages. Instead of the number of characters, it returns the number of bytes of a string.
```go
fmt.Println(len("a")) // prints 1
fmt.Println(len("ðŸ‘‹")) // prints 4
```
If we want the number of characters, we have to use the built-in package `unicode/utf8` and use the `RuneCountInString` function.
```go
fmt.Println(utf8.RuneCountInString("ðŸ‘‹")) // prints 1
```
Runes are actually another datatype in GO that represents characters. We can use the `rune` keyword to declare a variable of type rune. We use the single quote to declare a rune.
```go
var myRune rune = 'a'
```
As usual, booleans are declared using the `bool` type. They can either be `true` or `false`.

Variables in GO can be declared without initializing a value.
```go
var myInt int
```
In this case, GO sets a default value for the variable. For integer types, float types, and runes, the default value is 0. For strings, the default value is an empty string, and for booleans, the default value is `false`.

We can also declare a variable but omit the type if we initialize it with a value. GO will infer the type of the variable from the value.
```go
var myVar = "text"
```
We can go a step further and drop the `var` keyword as well by using the `:=` operator. This is called a short declaration.
```go
myVar := "text"
```
We can also declare multiple variables at once.
```go
var myVar1, myVar2, myVar3 int = 1, 2, 3
var myVar4, myVar5, myVar6 = 1, 2, 3
myVar7, myVar8, myVar9 := 1, 2, 3
```
Note that we should always add the type if it is not immediately obvious. For example, if we have a function that returns a value, we should add the type to the variable.
```go
var myVar string = foo()
```
We can also declare constants in GO using the `const` keyword. Constants are immutable, and their value cannot be changed after they are initialized. Constants cannot be declared but not initialized.
```go
const myConst int = 5
const myConst2 string // This will throw an error
```

## Functions and Control Structures
A function in GO is defined as follows:
```go
func myFunction(param1 type1, param2 type2) returnType {
    // code here
}
```
So for example
```go
func intDivision(numerator int, denominator int) int {
    var result int = numerator / denominator
    return result
}
```
A function can return multiple values by using parentheses.
```go
func intDivision(numerator int, denominator int) (int, int) {
    var result int = numerator / denominator
    var remainder int = numerator % denominator
    return result, remainder
}
```
We can use the `Printf` function from the `fmt` package to print to the console with formatting. We use the `%` symbol to indicate where we want to insert a value, and then we list the values at the end of the function call.
```go
fmt.Printf("The result is %d and the remainder is %d", result, remainder)
```
Now what if we pass 0 as a denominator to our division function? There will be a divide by zero error. A design pattern in GO is that if your function can encounter errors, your function should also return a value of type `error` along with the other return values. The `error` type is a built-in type in GO. When we declare an `error` variable, the default value is `nil`.
```go
import (
    "errors",
    "fmt"
)

func intDivision(numerator int, denominator int) (int, int, error) {
    var err error
    if denominator == 0 {
        err = errors.New("Cannot divide by zero")
        return 0, 0, err
    }
    var result int = numerator / denominator
    var remainder int = numerator % denominator
    return result, remainder, err // err is nil here
}

// Then we perform error checking
func main() {
    var result, remainder, err = intDivision(11, 0)
    if err != nil {
        fmt.Printf(err.Error())
    } else if remainder == 0 {
        fmt.Printf("The result is %v", result)
    } else {
        fmt.Printf("The result is %v and the remainder is %v", result, remainder)
    }
}
```
## Arrays, Slices, Maps, and Loops
### Arrays
Arrays are a collection of data with fixed length, same type, indexable, and stored in contiguous memory. The following declares an array of 3 integers.
```go
func main() {
    var intArr [3]int32
    intArr[1] = 123
    fmt.Println(intArr[0]) // gets the first element, 0
    fmt.Println(intArr[1:3]) // gets the second and third element, [123 0]
}
```
Note that the length of the array cannot be changed afterwards. We can print out the memory location of the array using the `&` operator.
```go
fmt.Println(&intArr) // prints the memory location of the first element
fmt.Println(&intArr[1]) // prints the memory location of the second element
```
We could also immediately initialize the array using the following syntax:
```go
var intArr1 [3]int32 = [3]int32{1, 2, 3}
var intArr2 := [3]int32{1, 2, 3}
// We could even omit the length of the array by using the ... syntax
var intArr3 := [...]int32{1, 2, 3}
```
### Slices
Slice are a more flexible version of arrays. Slices wrap arrays to give a more general, powerful, and convenient interface to sequences of data. By omitting the length of the array, we create a slice.
```go
var intSlice []int32 = []int32{1, 2, 3}
intAlice = append(intSlice, 7)
```
A slice has a `length` and a `capacity`. The length is the number of elements in the slice, and the capacity is the number of elements in the underlying array, starting from the first element of the slice. When we append an element to a slice, GO checks if the capacity is enough to store the new element. If it is not, GO creates a new array with double the capacity, copies the old array into the new array, and then appends the new element. 
```go
var intSlice []int32 = []int32{4, 5, 6}
fmt.Printf("The length is %v with capacity %v", len(intSlice), cap(intSlice)) //prints 3, 3
intAlice = append(intSlice, 7)
fmt.Printf("The length is %v with capacity %v", len(intSlice), cap(intSlice)) //prints 4, 6
```
We can append multiple elements to a slice by using the `...` syntax.
```go
var intSlice2 []int32 = []int32{1, 2, 3}
var intSlice3 []int32 = []int32{4, 5, 6}
intSlice2 = append(intSlice2, intSlice3...)
fmt.Println(intSlice2) // prints [1 2 3 4 5 6]
```
Another way to create a slice is to use the `make` function. We specify the length of the slice along with (optionally) the capacity of the slice. If you roughly know how many elements you will be appending to the slice, it is a good idea to specify the capacity to avoid unnecessary reallocation of arrays.
```go
var intSlice3 []int32 = make([]int32, 3, 8) // creates a slice of length 3 and capacity 8
```
### Maps
A map is a set of key-value pairs where you can lookup a value by its key. We can create a map using the `make` function.
```go
var myMap map[string]uint8 = make(map[string]uint8) // creates an empty map of key type string and value type uint8

var myMap2 = map[string]uint8{
    "one": 1,
    "two": 2,
    "three": 3,
}
```
If we try to access a value using a key that does not exist in that map, we get the default value of the value type.
```go
fmt.Println(myMap2["four"]) // prints 0
```
Luckily, GO returns two values when we access a value from a map. The first value is the value of the key, and the second value is a boolean that tells us if the key exists in the map.
```go
var value, exists = myMap2["four"]
if exists {
    fmt.Println(value)
} else {
    fmt.Println("The key does not exist")
}
```
We can also delete a key-value pair from a map using the `delete` function. No return value is given.
```go
delete(myMap2, "one")
```
### Loops
If we want to loop over arrays, slices, or maps, we can use the `range` keyword in a `for` loop.
```go
// loops over the keys of the map
for number := range myMap2 {
    fmt.Printf("%v\n", number)
}
```
Note that when we loop over a map, the ordering of the keys is not guaranteed, so we might get different orders each time we run the program. If we also want to loop over the values, we can do it like this:
```go
// loops over the keys and values of the map
for key, value := range myMap2 {
    fmt.Printf("%v: %v\n", key, value)
}
```
Similarly, we can loop over arrays and slices.
```go
for index, value := range intSlice2 {
    fmt.Printf("Index: %v, Value: %v\n", index, value)
}
```
GO does not have `while` loops, but we can achieve the same thing using the `for` keyword.
```go
var i int = 0
for i < 10 {
    fmt.Println(i)
    i = i + 1
}
// can also omit the condition
for {
    if i >= 10 {
        break
    }
    fmt.Println(i)
    i = i + 1
}
```
Another way to define a loop is using the syntax similar to C.
```go
for i:= 0; i < 10; i++ {
    fmt.Println(i)
}
```
## Strings, Runes, and Bytes